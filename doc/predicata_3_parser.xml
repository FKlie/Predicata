<Chapter Label="Parser"><Heading>Parsing first-order formulas</Heading>

<Section><Heading>PredicataFormula &#8211; strings representing first-order formulas</Heading>

<ManSection>
<Var Name="PredicataFormulaSymbols"/>
<Description>
The variable <C>PredicataFormulaSymbols</C> stores all inbuilt function symbols.
<Example><![CDATA[
gap> PredicataFormulaSymbols;
[ "*", "+", "-", "=", "gr", "geq", "less", "leq", "and", "or", "equiv", 
"equivalent", "implies", "not", "(", ")", "[", "]", ",", ":", "A", "E" ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="PredicataIsStringType" Arg="S, T"/>
<Description>
The function <C>PredicataIsStringType</C> checks if the string <A>S</A> represents one types <A>T</A><C>="variable", "integer" (greater equal 0), "negativeinteger", "boolean", "predicate", "internalpredicate", "quantifier", "symbol", "binarysymbol", "unarysymbol"</C>.
 <Ref Var="PredicataFormulaSymbols"/>.
<Example><![CDATA[
gap> PredicataIsStringType("x1", "variable");
true
gap> PredicataIsStringType("1", "integer");
true
gap> PredicataIsStringType("-1", "negativeinteger");
true
gap> PredicataIsStringType("true", "boolean");
true
gap> PredicataIsStringType("A", "quantifier");
true
gap> PredicataIsStringType("+", "symbol");
true
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="PredicataGrammarVerification" Arg="S,[ P]"/>
<Description>
The function <C>PredicataGrammarVerification</C> checks if the string <A>S</A>, with the optional argument 
<Ref Func="PredicataRepresentation"/> <A>P</A>, is a well-formed formula in the Presburger arithmetic. First a lexical analysis is performed, checking if all symbols are correct. Then it is checked if the formula can be produced from the predefined grammar (see <Ref Func="PredicataGrammar"/>). Finally, the range of the quantified variables is checked, as well as if all bounded variables doesn't also occur as free ones. Additionally, if the amount of opening and closing parenthesis differs, a corresponding message is returned.
<Example><![CDATA[
gap> PredicataGrammarVerification("4+x=2*y");
true
gap> PredicataGrammarVerification("(E x:3+x=2*y)");
true
gap> PredicataGrammarVerification("= , 2 + <= x 4");
false
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="PredicataFormula" Arg="S,[ P]"/>
<Description>
The function <C>PredicataFormula</C> takes a string <A>S</A>, checks if it's a formula in the language of Presburger arithmetic (using with <Ref Func="PredicataGrammarVerification"/>) and returns a <C>PredicataFormula</C> (use <Ref Func="PredicataGrammar"/> for an overview of the rules). The optional input <A>P</A> is explained at <Ref Func="PredicataRepresentation"/>, however on default the predefined variable <Ref Var="PredicataList"/> is used.
<Example><![CDATA[
gap> PredicataFormula("(E y: x + y = z)");
< PredicataFormula: ( E y : x + y = z ) >
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="IsPredicataFormula" Arg="f"/>
<Description>
The function <C>IsPredicataFormula</C> checks if <A>f</A> is a <C>PredicataFormula</C>.
<Example><![CDATA[
gap> f:=PredicataFormula("(E y: x + y = z)");
< PredicataFormula: ( E y : x + y = z ) >
gap> IsPredicataFormula(f);
true
]]></Example>
</Description>
</ManSection>

<ManSection>
<Meth Name="Display" Arg="f" Label="PredicataFormula"/>
<Description>
The method <C>Display</C> displays the <C>PredicataFormula</C> <A>f</A>.
<Example><![CDATA[
gap> f:=PredicataFormula("(A x: (E y: x = y))");
< PredicataFormula: ( A x : ( E y : x = y ) ) >
gap> Display(f);
PredicataFormula: ( A x : ( E y : x = y ) ).
]]></Example>
</Description>
</ManSection>

<ManSection>
<Meth Name="View" Arg="f" Label="PredicataFormula"/>
<Description>
The method <C>View</C> applied on a <C>PredicataFormula</C> <A>f</A> returns the object text.
<Example><![CDATA[
gap> f:=PredicataFormula("x + y = z");;
gap> View(f);
< PredicataFormula: x + y = z >
]]></Example>
</Description>
</ManSection>

<ManSection>
<Meth Name="Print" Arg="f" Label="PredicataFormula"/>
<Description>
The method <C>Print</C> prints the <C>PredicataFormula</C> <A>f</A> as a string.
<Example><![CDATA[
gap> f:=PredicataFormula("x = 4 and not x = 5");
< PredicataFormula: x = 4 and not x = 5 >
gap> Print(f);
PredicataFormula("x = 4 and not x = 5");
gap> String(f);
"PredicataFormula(\"x = 4 and not x = 5\");"
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="FreeVariablesOfPredicataFormula" Arg="f"/>
<Description>
The function <C>FreeVariablesOfPredicataFormula</C> returns the free variables of the <C>PredicataFormula</C> <A>f</A> as a list of strings.
<Example><![CDATA[
gap> f:=PredicataFormula("(E n: 3*n = x) or (E m: 4*m = x)");
< PredicataFormula: ( E n : 3 * n = x ) or ( E m : 4 * m = x ) >
gap> FreeVariablesOfPredicataFormula(f);
[ "x" ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="BoundedVariablesOfPredicataFormula" Arg="f"/>
<Description>
The function <C>BoundedVariablesOfPredicataFormula</C> returns the bounded variables of the <C>PredicataFormula</C> <A>f</A> as a list of strings.
<Example><![CDATA[
gap> f:=PredicataFormula("(E n: 3*n = x) or (E m: 4*m = x)");
< PredicataFormula: ( E n : 3 * n = x ) or ( E m : 4 * m = x ) >
gap> BoundedVariablesOfPredicataFormula(f);
[ "n", "m" ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="PredicataFormulaFormatted" Arg="f,[ P]"/>
<Description>
The function <C>PredicataFormulaFormatted</C> adds missing parenthesis to the <C>PredicataFormula</C> <A>f</A> for unambiguous parsing in <Ref Func="PredicataFormulaFormattedToTree"/>.
<Example><![CDATA[
gap> f:=PredicataFormula("(E y: x + y = z)");
< PredicataFormula: ( E y : x + y = z ) >
gap> F:=PredicataFormulaFormatted(f);
< PredicataFormulaFormatted: ( E y : ( ( x + y ) = z ) ) >
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="IsPredicataFormulaFormatted" Arg="f"/>
<Description>
The function <C>IsPredicataFormulaFormatted</C> checks if <A>f</A> is a <C>PredicataFormula</C>.
<Example><![CDATA[
gap> f:=PredicataFormula("(E y: x + y = z)");
< PredicataFormula: ( E y : x + y = z ) >
gap> F:=PredicataFormulaFormatted(f);
< PredicataFormulaFormatted: ( E y : ( ( x + y ) = z ) ) >
gap> IsPredicataFormulaFormatted(F);
true
]]></Example>
</Description>
</ManSection>

<ManSection>
<Meth Name="Display" Arg="F" Label="PredicataFormulaFormatted"/>
<Description>
The method <C>Display</C> displays the <C>PredicataFormulaFormatted</C> <A>F</A>. 
<Example><![CDATA[
gap> F:=PredicataFormulaFormatted(PredicataFormula("(E y: x + y = z)"));
< PredicataFormulaFormatted: ( E y : ( ( x + y ) = z ) ) >
gap> Display(F);
PredicataFormulaFormatted: [ "(", "E", "y", ":", "(", "(", "x", "+", "y", ")", 
"=", "z", ")", ")" ].
Concatenation: (Ey:((x+y)=z)).
]]></Example>
</Description>
</ManSection>

<ManSection>
<Meth Name="View" Arg="f" Label="PredicataFormulaFormatted"/>
<Description>
The method <C>View</C> applied on a <C>PredicataFormulaFormatted</C> <A>F</A> returns the object text.
<Example><![CDATA[
gap> f:=PredicataFormula("x + y = z");;
gap> F:=PredicataFormulaFormatted(f);;
gap> View(F);
< PredicataFormulaFormatted: ( ( x + y ) = z ) >
]]></Example>
</Description>
</ManSection>

<ManSection>
<Meth Name="Print" Arg="F" Label="PredicataFormulaFormatted"/>
<Description>
The method <C>Print</C> prints the <C>PredicataFormulaFormatted</C> <A>F</A> as a string.
<Example><![CDATA[
gap> F:=PredicataFormulaFormatted(PredicataFormula("x = 4 and not x = 5"));
< PredicataFormulaFormatted: ( ( x = 4 ) and ( not ( x = 5 ) ) ) >
gap> Print(F);
PredicataFormulaFormatted(PredicataFormula(s"((x=4)and(not(x=5)))"));
gap> String(F);
"PredicataFormulaFormatted(PredicataFormula(\"((x=4)and(not(x=5)))\"));"
]]></Example>
</Description>
</ManSection>

</Section>

<Section><Heading>PredicataTree &#8211; converting first-order formulas into trees</Heading>

<ManSection>
<Func Name="PredicataTree" Arg="[r]"/>
<Description>
The function <C>PredicataTree</C> creates the a tree with root <A>r</A>, which may be empty.
<Example><![CDATA[
gap> PredicataTree("root");
< PredicataTree: [ "root" ] >
gap> PredicataTree();
< PredicataTree: [ "" ] >
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="IsPredicataTree" Arg="t"/>
<Description>
The function <C>IsPredicataTree</C> checks if <A>t</A> is a <C>PredicataTree</C>.
<Example><![CDATA[
gap> f:=PredicataFormula("(E y: x + y = z)");
< PredicataFormula: ( E y : x + y = z ) >
gap> IsPredicataFormula(f);
true
]]></Example>
</Description>
</ManSection>

<ManSection>
<Meth Name="Display" Arg="t" Label="PredicataTree"/>
<Description>
The method <C>Display</C> prints the <C>PredicataTree</C> <A>t</A> as a nested list, i.e. it's internal structure.
<Example><![CDATA[
gap> t:=PredicataTree("only one element");
< PredicataTree: [ "only one element" ] >
gap> Display(t);
PredicataTree: [ "only one element" ].
]]></Example>
</Description>
</ManSection>

<ManSection>
<Meth Name="View" Arg="t" Label="PredicataTree"/>
<Description>
The method <C>View</C> applied on a <C>PredicataTree</C> <A>t</A> returns the object text.
<Example><![CDATA[
gap> t:=PredicataTree("root");;
gap> View(t);
< PredicataTree: [ "root" ] >
]]></Example>
</Description>
</ManSection>

<ManSection>
<Meth Name="Print" Arg="t" Label="PredicataTree"/>
<Description>
The method <C>Print</C> prints the <C>PredicataTree</C> <A>t</A> as a string.
<Example><![CDATA[
gap> t:=PredicataTree("root");;
gap> Print(t);
PredicataTree: [ "root" ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="IsEmptyPredicataTree" Arg="t"/>
<Description>
The function <C>IsEmptyPredicataTree</C> checks if a given <C>PredicataTree</C> <A>t</A> is empty.
<Example><![CDATA[
gap> t:=PredicataTree("root");
< PredicataTree: [ "root" ] >
gap> IsEmptyPredicataTree(t);
false
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="RootOfPredicataTree" Arg="t"/>
<Description>
The function <C>RootOfPredicataTree</C> returns the current root of the <C>PredicataTree</C> <A>t</A>.
<Example><![CDATA[
gap> t:=PredicataTree("current root");
< PredicataTree: [ "current root" ] >
gap> RootOfPredicataTree(t);
"current root"
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="SetRootOfPredicataTree" Arg="t, n"/>
<Description>
The function <C>SetRootOfPredicataTree</C> changes the current root of the <C>PredicataTree</C> <A>t</A> to the input <A>n</A>.
<Example><![CDATA[
gap> SetRootOfPredicataTree(t, "element #2");
gap> t:=PredicataTree("element #1");
< PredicataTree: [ "element #1" ] >
gap> SetRootOfPredicataTree(t, "element #2");
gap> Display(t);
PredicataTree: [ "element #2" ].
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="InsertChildToPredicataTree" Arg="t"/>
<Description>
The function <C>InsertChildToPredicataTree</C> inserts a child to the current <C>PredicataTree</C> <A>t</A>.
<Example><![CDATA[
gap> t:=PredicataTree("root");
< PredicataTree: [ "root" ] >
gap> InsertChildToPredicataTree(t);
gap> Display(t);
PredicataTree: [ "root", [ ] ].
gap> InsertChildToPredicataTree(t);
gap> Display(t);
PredicataTree: [ "root", [ ], [ ] ].
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="ChildOfPredicataTree" Arg="t, i"/>
<Description>
The function <C>ChildOfPredicataTree"</C> enters the <A>i</A>-th child of the current <C>PredicataTree</C> <A>t</A>.
<Example><![CDATA[
gap> t:=PredicataTree("root");
< PredicataTree: [ "root" ] >
gap> InsertChildToPredicataTree(t);
gap> ChildOfPredicataTree(t, 1);
< PredicataTree: [ "root", [ ] ] >
gap> SetRootOfPredicataTree(t, "child 1");
gap> Display(t);
PredicataTree: [ "root", [ "child 1" ] ].
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="NumberOfChildrenOfPredicataTree" Arg="t"/>
<Description>
The function <C>NumberOfChildrenOfPredicataTree</C> returns the number of children of the current <C>PredicataTree</C> <A>t</A>.
<Example><![CDATA[
gap> t:=PredicataTree("root");
< PredicataTree: [ "root" ] >
gap> NumberOfChildrenOfPredicataTree(t);
0
gap> InsertChildToPredicataTree(t);
gap> InsertChildToPredicataTree(t);
gap> NumberOfChildrenOfPredicataTree(t);
2
gap> ChildOfPredicataTree(t, 1);
< PredicataTree: [ "root", [ ], [ ] ] >
gap> SetRootOfPredicataTree(t, "child 1");
gap> Display(t);
PredicataTree: [ "root", [ "child 1" ], [ ] ].
gap> NumberOfChildrenOfPredicataTree(t);
0
gap> InsertChildToPredicataTree(t);
gap> InsertChildToPredicataTree(t);
gap> NumberOfChildrenOfPredicataTree(t);
2
gap> Display(t);
PredicataTree: [ "root", [ "child 1", [ ], [ ] ], [ ] ].
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="ParentOfPredicataTree" Arg="t"/>
<Description>
The function <C>ParentOfPredicataTree</C> goes back to the parent of the current <C>PredicataTree</C> <A>t</A>.
<Example><![CDATA[
gap> t:=PredicataTree("root");
< PredicataTree: [ "root" ] >
gap> InsertChildToPredicataTree(t);
gap> InsertChildToPredicataTree(t);
gap> Display(t);
PredicataTree: [ "root", [ ], [ ] ].
gap> ChildOfPredicataTree(t, 1);
< PredicataTree: [ "root", [ ], [ ] ] >
gap> SetRootOfPredicataTree(t, "child 1");     
gap> ParentOfPredicataTree(t);
< PredicataTree: [ "root", [ "child 1" ], [ ] ] >
gap> ChildOfPredicataTree(t, 2);
< PredicataTree: [ "root", [ "child 1" ], [ ] ] >
gap> SetRootOfPredicataTree(t, "child 2");
gap> Display(t);
PredicataTree: [ "root", [ "child 1" ], [ "child 2" ] ].
]]></Example>
</Description>
</ManSection>


<ManSection>
<Func Name="ReturnedChildOfPredicataTree" Arg="t, i"/>
<Description>
The function <C>ReturnedChildOfPredicataTree</C> returns the <A>i</A>-th child of the current <C>PredicataTree</C> <A>t</A> as a new tree.
<Example><![CDATA[
gap> t:=PredicataTree("root");
< PredicataTree: [ "root" ] >
gap> InsertChildToPredicataTree(t);
gap> ChildOfPredicataTree(t, 1);
< PredicataTree: [ "root", [ ], [ ] ] >
gap> SetRootOfPredicataTree(t, "child 1");     
gap> ParentOfPredicataTree(t);
gap> r:=ReturnedChildOfPredicataTree(t, 1);
< PredicataTree: [ "child 1" ] >
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="PredicataFormulaFormattedToTree" Arg="F"/>
<Description>
The function <C></C> converts a <Ref Func="PredicataFormulaFormatted"/> <A>F</A> to a <C>PredicataTree</C>.
<Example><![CDATA[
gap> f:=PredicataFormula("(E y: x+y=z and y = x)");
< PredicataFormula: ( E y : x + y = z and y = x ) >
gap> F:=PredicataFormulaFormatted(f);
< PredicataFormulaFormatted: ( E y : ( ( ( x + y ) = z ) and ( y = x ) ) ) >
gap> t:=PredicataFormulaFormattedToTree(F);
< PredicataTree: [ "E", [ "y" ], [ "and", 
[ "=", [ "+", [ "x" ], [ "y" ] ], [ "z" ] ], [ "=", [ "y" ], [ "x" ] ] ] ] >

]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="FreeVariablesOfPredicataTree" Arg="t"/>
<Description>
The function <C>FreeVariablesOfPredicataTree</C> returns the free variables of the <C>PredicataTree</C> <A>t</A>, which have been carried over from the <Ref Func="PredicataFormula"/> and the <Ref Func="PredicataFormulaFormatted"/>.
<Example><![CDATA[
gap> f:=PredicataFormula("(E y: x+y=z and y = x)");
< PredicataFormula: ( E y : x + y = z and y = x ) >
gap> F:=PredicataFormulaFormatted(f);
< PredicataFormulaFormatted: ( E y : ( ( ( x + y ) = z ) and ( y = x ) ) ) >
gap> t:=PredicataFormulaFormattedToTree(F);
< PredicataTree: [ "E", [ "y" ], [ "and", [ "=", [ "+", [ "x" ], [ "y" ] ],
[ "z" ] ], [ "=", [ "y" ], [ "x" ] ] ] ] >
gap> FreeVariablesOfPredicataTree(t);
[ "x", "z" ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="BoundedVariablesOfPredicataTree" Arg="t"/>
<Description>
The function <C>BoundedVariablesOfPredicataTree</C> returns the bounded variables of the <C>PredicataTree</C> <A>t</A>, which have been carried over from the <Ref Func="PredicataFormula"/> and the <Ref Func="PredicataFormulaFormatted"/>.
<Example><![CDATA[
gap> f:=PredicataFormula("(E y: x+y=z and y = x)"); 
< PredicataFormula: ( E y : x + y = z and y = x ) >
gap> F:=PredicataFormulaFormatted(f);
< PredicataFormulaFormatted: ( E y : ( ( ( x + y ) = z ) and ( y = x ) ) ) >
gap> t:=PredicataFormulaFormattedToTree(F);
< PredicataTree: [ "E", [ "y" ], [ "and", [ "=", [ "+", [ "x" ], [ "y" ] ], 
[ "z" ] ], [ "=", [ "y" ], [ "x" ] ] ] ] >
gap> BoundedVariablesOfPredicataTree(t);
[ "y" ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="PredicataTreeToPredicaton" Arg="t,[ V]"/>
<Description>
The function <C>PredicataTreeToPredicaton</C> calls <Ref Func="PredicataTreeToPredicatonRecursive"/> to turn a <Ref Func="PredicataTree"/> <A>t</A> into a <Ref Func="Predicaton" Label="Automaton with variable position list"/>. The optional argument <A>V</A> allows to specify an order for the free variables in the tree.
<Example><![CDATA[
gap> f:=PredicataFormula("(E y: x+y=z and y = x)");   
< PredicataFormula: ( E y : x + y = z and y = x ) >
gap> F:=PredicataFormulaFormatted(f);
< PredicataFormulaFormatted: ( E y : ( ( ( x + y ) = z ) and ( y = x ) ) ) >
gap> t:=PredicataFormulaFormattedToTree(F);
< PredicataTree: [ "E", [ "y" ], [ "and", [ "=", [ "+", [ "x" ], [ "y" ] ], 
[ "z" ] ], [ "=", [ "y" ], [ "x" ] ] ] ] >
gap> P:=PredicataTreeToPredicaton(t);
[ "Pred", < Predicata: deterministic finite automaton on 4 letters with 3 states 
and the variable position list [ 1, 2 ]. > ]
gap> Display(P[2]);
Predicata: deterministic finite automaton on 4 letters with 3 states, 
the variable position list [ 1, 2 ] and the following transitions:
            |  1  2  3  
------------------------
  [ 0, 0 ]  |  3  2  3  
  [ 1, 0 ]  |  3  1  3  
  [ 0, 1 ]  |  2  3  3  
  [ 1, 1 ]  |  1  3  3  
 Initial states: [ 2 ]
 Final states:   [ 2 ]

 The alphabet corresponds to the following variable list: [ "x", "z" ].
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="PredicataTreeToPredicatonRecursive" Arg="t, V"/>
<Description>
The function <C>PredicataTreeToPredicatonRecursive</C> is called by <Ref Func="PredicataTreeToPredicaton"/> in order to convert a <C>PredicataTree</C> <A>t</A> into a <C>Predicata</C>. The list <A>V</A> contains as first entry a list of free variables (not necessarily occurring) and as second entry a list containing the previous variables together with all bounded variables. This function goes down into the tree recursively until it reaches its leaves. Upon going up it creates the automaton of the <C>Predicaton</C> with relation to the variable position list.
<Example><![CDATA[
gap> F:=PredicataFormulaFormatted(PredicataFormula("(E y: x+y=z and y = x)"));;
gap> t:=PredicataFormulaFormattedToTree(F);;
gap> P:=PredicataTreeToPredicatonRecursive(t, [[ "x", "z" ], [ "x", "y", "z" ]]);;
gap> Display(P[2]);
Predicata: deterministic finite automaton on 4 letters with 3 states, 
the variable position list [ 1, 3 ] and the following transitions:
            |  1  2  3  
------------------------
  [ 0, 0 ]  |  3  2  3  
  [ 1, 0 ]  |  3  1  3  
  [ 0, 1 ]  |  2  3  3  
  [ 1, 1 ]  |  1  3  3  
 Initial states: [ 2 ]
 Final states:   [ 2 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="PredicataRepresentationOfPredicataTree" Arg="t"/>
<Description>
The function <C>PredicataRepresentationOfPredicataTree</C> returns the <C>PredicataRepresentation</C> of a <C>PredicataTree</C> <A>t</A>. For more details see <Ref Func="PredicataRepresentation"/>.
<Example><![CDATA[
gap> t:=PredicataTree("root");;
gap> PredicataRepresentationOfPredicataTree(t);
< PredicataRepresentation containing the following predicates: [ ]. >
]]></Example>
</Description>
</ManSection>

</Section>

<Section><Heading>PredicataRepresentation &#8211; Predicata assigned with names and arities</Heading>
This section explains how to assign a name and an arity to a <C>Predicata</C> such that it can be reused in a <Ref Func="PredicataFormula"/>. The idea is to create elements containing the name, arity and the <C>Predicata</C> and combining them in a <Ref Func="PredicataRepresentation"/>. Additionally, there is a predefined variable <Ref Var="PredicataList"/>, which is called by the <C>PredicataFormula</C> on default, trying to simplify these quite lengthy construction.

<ManSection>
<Func Name="PredicatonRepresentation" Arg="name, arity, automaton"/>
<Description>
The function <C>PredicatonRepresentation</C> creates the representation of a Predicaton, assigned with a <A>name</A>, an <A>arity</A> and a <C>Predicaton</C>, allowing it to be called in a <Ref Func="PredicataFormula"/> with <C>Name[x1,...xN]</C> (where <C>N</C> is the arity).
<Example><![CDATA[
gap> A:=Predicaton(Automaton("det", 3, [ [ 0, 0, 0 ], [ 1, 0, 0 ], [ 0, 1, 0 ], 
> [ 1, 1, 0 ], [ 0, 0, 1 ], [ 1, 0, 1 ], [ 0, 1, 1 ], [ 1, 1, 1 ] ], 
> [ [ 1, 3, 3 ], [ 3, 2, 3 ], [ 3, 2, 3 ], [ 2, 3, 3 ], [ 3, 1, 3 ], 
> [ 1, 3, 3 ], [ 1, 3, 3 ], [ 3, 2, 3 ] ], [ 1 ], [ 1 ]), [ 1, 2, 3 ]);;
gap> p:=PredicatonRepresentation("MyAdd", 3, A);
< Predicaton represented with the name: "MyAdd", the arity: 3 
and the deterministic automaton on 8 letters and 3 states. >
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="IsPredicatonRepresentation" Arg="p"/>
<Description>
The function <C>IsPredicatonRepresentation</C> checks if the argument <A>p</A> is a <C>PredicatonRepresentation</C>.
<Example><![CDATA[
gap> A:=Predicaton(Automaton("det", 2, [ [ 0 ], [ 1 ] ], [ [ 1, 2 ], [ 2, 2 ] ],
> [ 1 ], [ 1 ]), [ 1 ]);;
gap> p:=PredicatonRepresentation("EqualZero", 1, A);
< Predicaton represented with the name "EqualZero", the arity 1 and 
the deterministic automaton on 2 letters and 2 states. >
gap> IsPredicatonRepresentation(p);
true
]]></Example>
</Description>
</ManSection>

<ManSection>
<Meth Name="Display" Arg="p" Label="PredicatonRepresentation"/>
<Description>
The method <C>Display</C> prints the <C>PredicatonRepresentation</C> <A>p</A>.
<Example><![CDATA[
gap> A:=Predicaton(Automaton("det", 2, [ [ 0 ], [ 1 ] ], [ [ 1, 2 ], [ 2, 2 ] ], 
> [ 1 ], [ 1 ]), [ 1 ]);;
gap> p:=PredicatonRepresentation("EqualZero", 1, A);;
gap> Display(p);
Predicaton represented with the name: EqualZero, the arity: 1 and the following Predicaton:
Predicaton: deterministic finite automaton on 2 letters with 2 states,
the variable position list [ 1 ] and the following transitions:
         |  1  2
------------------
  [ 0 ]  |  1  2
  [ 1 ]  |  2  2
 Initial states: [ 1 ]
 Final states:   [ 1 ]

]]></Example>
</Description>
</ManSection>

<ManSection>
<Meth Name="View" Arg="p" Label="PredicatonRepresentation"/>
<Description>
The method <C>View</C> applied on a <C>PredicatonRepresentation</C> <A>p</A> returns the object text.
<Example><![CDATA[
gap> A:=Predicaton(Automaton("det", 4, [ [ 0, 0 ], [ 1, 0 ], [ 0, 1 ], [ 1, 1 ] ],
> [ [ 1, 2, 2, 3 ], [ 2, 2, 4, 2 ], [ 2, 2, 1, 2 ], [ 3, 2, 2, 4 ] ],
> [ 1 ], [ 1 ]), [ 1, 2 ]);;
gap> p:=PredicatonRepresentation("MultipleOfThree", 2, A);;
gap> View(p);
< Predicaton represented with the name "MultipleOfThree", the arity 2 and 
the deterministic automaton on 4 letters and 4 states. >
]]></Example>
</Description>
</ManSection>

<ManSection>
<Meth Name="Print" Arg="p" Label="PredicatonRepresentation"/>
<Description>
The method <C>Print</C> prints the <C>PredicatonRepresentation</C> <A>p</A> as a string.
<Example><![CDATA[
gap> A:=Predicaton(Automaton("det", 2, [ [ 0 ], [ 1 ] ], [ [ 1, 2 ], [ 2, 2 ] ],
> [ 1 ], [ 2 ]), [ 1 ]);;
gap> p:=PredicatonRepresentation("GreaterZero", 1, A);;
gap> Print(p);
PredicatonRepresentation("GreaterZero", 1, Predicaton(Automaton("det",
2, [ [ 0 ], [ 1 ] ], [ [ 1, 2 ], [ 2, 2 ] ], [ 1 ], [ 2 ]), [ 1 ], 2))

gap> String(p);
"PredicatonRepresentation(\"GreaterZero\", 1, Predicaton(Automaton(\"det\",
2, [ [ 0 ], [ 1 ] ], [ [ 1, 2 ], [ 2, 2 ] ], [ 1 ], [ 2 ]), [ 1 ], 2))"
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="NameOfPredicatonRepresentation" Arg="p"/>
<Description>
The function <C>NameOfPredicatonRepresentation</C> returns the <C>name</C> of <A>p</A>.
<Example><![CDATA[
gap> A:=Predicaton(Automaton("det", 4, [ [ 0 ], [ 1 ] ], [ [ 4, 2, 3, 3 ],
> [ 3, 3, 3, 2 ] ], [ 1 ], [ 3, 4, 1 ]), [ 1 ]);;
gap> p:=PredicatonRepresentation("NotTwo", 1, A);;
gap> NameOfPredicatonRepresentation(p);
"NotTwo"
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="ArityOfPredicatonRepresentation" Arg="p"/>
<Description>
The function <C>ArityOfPredicatonRepresentation</C> returns the <C>arity</C> of <A>p</A>.
<Example><![CDATA[
gap> A:=Predicaton(Automaton("det", 4, [ [ 0 ], [ 1 ] ], [ [ 4, 2, 3, 3 ],
> [ 3, 3, 3, 2 ] ], [ 1 ], [ 3, 4, 1 ]), [ 1 ]);;
gap> p:=PredicatonRepresentation("NotTwo", 1, A);;
gap> ArityOfPredicatonRepresentation(p);
1
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="PredicatonOfPredicatonRepresentation" Arg="p"/>
<Description>
The function <C>PredicatonOfPredicatonRepresentation</C> returns the <C>Predicaton</C> of <A>p</A>.
<Example><![CDATA[
gap> A:=Predicaton(Automaton("det", 4, [ [ 0 ], [ 1 ] ], [ [ 4, 2, 3, 3 ],
> [ 3, 3, 3, 2 ] ], [ 1 ], [ 3, 4, 1 ]), [ 1 ]);;
gap> p:=PredicatonRepresentation("NotTwo", 1, A);;
gap> PredicatonOfPredicatonRepresentation(p);
< Predicaton: deterministic finite automaton on 2 letters with 4 states 
and the variable position list [ 1 ]. >
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="BaseOfPredicatonRepresentation" Arg="p"/>
<Description>
The function <C>BaseOfPredicatonRepresentation</C> returns the <C>Base</C> of the <C>Predicaton</C> <A>p</A>.
<Example><![CDATA[
gap> A:=Predicaton(Automaton("det", 4, [ [ 0 ], [ 1 ] ], [ [ 4, 2, 3, 3 ],
> [ 3, 3, 3, 2 ] ], [ 1 ], [ 3, 4, 1 ]), [ 1 ]);;
gap> p:=PredicatonRepresentation("NotTwo", 1, A);;
gap> BaseOfPredicatonRepresentation(p);
2
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="AutOfPredicatonRepresentation" Arg="p"/>
<Description>
The function <C>AutOfPredicatonRepresentation</C> returns the <C>Automaton</C> of the <C>Predicaton</C> <A>p</A>.
<Example><![CDATA[
gap> A:=Predicaton(Automaton("det", 4, [ [ 0 ], [ 1 ] ], [ [ 4, 2, 3, 3 ],
> [ 3, 3, 3, 2 ] ], [ 1 ], [ 3, 4, 1 ]), [ 1 ]);;
gap> p:=PredicatonRepresentation("NotTwo", 1, A);;
gap> AutOfPredicatonRepresentation(p);
< deterministic automaton on 2 letters with 4 states >
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="CopyPredicatonRepresentation" Arg="p"/>
<Description>
The function <C>CopyPredicatonRepresentation</C> copies <A>p</A>.
<Example><![CDATA[
gap> A:=Predicaton(Automaton("det", 3, [ [ 0, 0 ], [ 1, 0 ], [ 0, 1 ], [ 1, 1 ] ],
> [ [ 1, 3, 3 ], [ 2, 3, 3 ], [ 3, 1, 3 ], [ 3, 2, 3 ] ], [ 1 ], [ 1 ]), [ 1, 2 ] );;
gap> p:=PredicatonRepresentation("CopyPred", 2, A);;
gap> q:=CopyPredicatonRepresentation(p);
< Predicaton represented with the name "CopyPred", the arity 2 and 
the deterministic automaton on 4 letters and 3 states. >
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="PredicataRepresentation" Arg="[l]"/>
<Description>
The function <C>PredicataRepresentation</C> creates a collection of elements (<Ref Func="PredicatonRepresentation"/>), where the list <A>l</A> may contain arbitrary many of them. The <C>PredicataRepresentation</C> is an optional input for the function <Ref Func="PredicataFormula"/> (On default it uses the predefined variable <Ref Var="PredicataList"/>). Note that the variables must be unique within one predicate call.
<Example><![CDATA[
gap> A1:=Predicaton(Automaton("det", 3, [ [ 0, 0, 0 ], [ 1, 0, 0 ], [ 0, 1, 0 ], 
> [ 1, 1, 0 ], [ 0, 0, 1 ], [ 1, 0, 1 ], [ 0, 1, 1 ], [ 1, 1, 1 ] ], 
> [ [ 1, 3, 3 ], [ 3, 2, 3 ], [ 3, 2, 3 ], [ 2, 3, 3 ], [ 3, 1, 3 ], 
> [ 1, 3, 3 ], [ 1, 3, 3 ], [ 3, 2, 3 ] ], [ 1 ], [ 1 ]), [ 1, 2, 3 ]);;
gap> p1:=PredicatonRepresentation("MyAdd", 3, A1);
< Predicaton represented with the name "MyAdd", the arity 3 and 
the deterministic automaton on 8 letters and 3 states. >
gap> A2:=Predicaton(Automaton("det", 2, [ [ 0, 0 ], [ 1, 0 ], [ 0, 1 ], [ 1, 1 ] ],
> [ [ 1, 2 ], [ 2, 2 ], [ 2, 2 ], [ 1, 2 ] ], [ 1 ], [ 1 ]), [ 1, 2 ]);;
gap> p2:=PredicatonRepresentation("MyEqual", 2, A2);;
gap> P:=PredicataRepresentation(p1, p2);
< PredicataRepresentation containing the following predicates: 
[ "MyEqual", "MyAdd"]. >
gap> f:=PredicataFormula("MyAdd[x,y,z] and MyEqual[x,y]", P);
< PredicataFormula: MyAdd [ x , y , z ] and MyEqual [ x , y ] >
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="IsPredicataRepresentation" Arg="P"/>
<Description>
The function <C>IsPredicataRepresentation</C> checks if the argument <A>P</A> is a <C>PredicataRepresentation</C>.
<Example><![CDATA[
gap> # Continued example: PredicataRepresentation
gap> IsPredicataRepresentation(P);
true
]]></Example>
</Description>
</ManSection>

<ManSection>
<Meth Name="Display" Arg="p" Label="PredicataRepresentation"/>
<Description>
The method <C>Display</C> prints the <C>PredicataRepresentation</C> <A>P</A>.
<Example><![CDATA[
gap> # Continued example: PredicataRepresentation
gap> Display(P);
Predicata representation containing the following PredicatonRepresentations:
Predicaton represented with the name: MyEqual, the arity: 2 and the following Predicaton:
Predicaton: deterministic finite automaton on 4 letters with 2 states,
the variable position list [ 1, 2 ] and the following transitions:
            |  1  2
---------------------
  [ 0, 0 ]  |  1  2
  [ 1, 0 ]  |  2  2
  [ 0, 1 ]  |  2  2
  [ 1, 1 ]  |  1  2
 Initial states: [ 1 ]
 Final states:   [ 1 ]
Predicaton represented with the name: MyAdd, the arity: 3 and the following Predicaton:
Predicaton: deterministic finite automaton on 8 letters with 3 states,
 the variable position list [ 1, 2, 3 ] and the following transitions:
               |  1  2  3
---------------------------
  [ 0, 0, 0 ]  |  1  3  3
  [ 1, 0, 0 ]  |  3  2  3
  [ 0, 1, 0 ]  |  3  2  3
  [ 1, 1, 0 ]  |  2  3  3
  [ 0, 0, 1 ]  |  3  1  3
  [ 1, 0, 1 ]  |  1  3  3
  [ 0, 1, 1 ]  |  1  3  3
  [ 1, 1, 1 ]  |  3  2  3
 Initial states: [ 1 ]
 Final states:   [ 1 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Meth Name="View" Arg="P" Label="PredicataRepresentation"/>
<Description>
The method <C>View</C> applied on a <C>PredicataRepresentation</C> <A>P</A> returns the object text.
<Example><![CDATA[
gap> P:=PredicataRepresentation();;
gap> View(P);
< PredicataRepresentation containing the following predicates: [ ]. >
]]></Example>
</Description>
</ManSection>

<ManSection>
<Meth Name="Print" Arg="P" Label="PredicataRepresentation"/>
<Description>
The method <C>Print</C> prints the <C>PredicataRepresentation</C> <A>P</A> as a string.
<Example><![CDATA[
gap> # Continued example: PredicataRepresentation
gap> Print(P);
PredicataRepresentation(PredicatonRepresentation("MyEqual", 2, Predicaton( \
Automaton("det", 2, [ [ 0, 0 ], [ 1, 0 ], [ 0, 1 ], [ 1, 1 ] ], [ [ 1, 2 ],\
[ 2, 2 ], [ 2, 2 ], [ 1, 2 ] ], [ 1 ], [ 1 ]), [ 1, 2 ], 2)), PredicatonRep\
resentation("MyAdd", 3, Predicaton(Automaton("det", 3, [ [ 0, 0, 0 ], [ 1, \
0, 0 ], [ 0, 1, 0 ], [ 1, 1, 0 ], [ 0, 0, 1 ], [ 1, 0, 1 ], [ 0, 1, 1 ], [ \
1, 1, 1 ] ], [ [ 1, 3, 3 ], [ 3, 2, 3 ], [ 3, 2, 3 ], [ 2, 3, 3 ], [ 3, 1, \
3 ], [ 1, 3, 3 ], [ 1, 3, 3 ], [ 3, 2, 3 ] ], [ 1 ], [ 1 ]), [ 1, 2, 3 ], 2\
)))
gap> String(P);
"PredicataRepresentation(PredicatonRepresentation(\"MyEqual\", 2, Predicato\
n(Automaton(\"det\", 2, [ [ 0, 0 ], [ 1, 0 ], [ 0, 1 ], [ 1, 1 ] ], [ [ 1, \
2 ], [ 2, 2 ], [ 2, 2 ], [ 1, 2 ] ], [ 1 ], [ 1 ]), [ 1, 2 ], 2)), Predicat\
onRepresentation(\"MyAdd\", 3, Predicaton(Automaton(\"det\", 3, [ [ 0, 0, 0\
 ], [ 1, 0, 0 ], [ 0, 1, 0 ], [ 1, 1, 0 ], [ 0, 0, 1 ], [ 1, 0, 1 ], [ 0, 1\
 , 1 ], [ 1, 1, 1 ] ], [ [ 1, 3, 3 ], [ 3, 2, 3 ], [ 3, 2, 3 ], [ 2, 3, 3 ]\
 , [ 3, 1, 3 ], [ 1, 3, 3 ], [ 1, 3, 3 ], [ 3, 2, 3 ] ], [ 1 ], [ 1 ]), [ 1\
 , 2, 3 ], 2)))"
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="NamesOfPredicataRepresentation" Arg="P"/>
<Description>
The function <C>NamesOfPredicataRepresentation</C> returns the names of <A>P</A>.
<Example><![CDATA[
gap> # Continued example: PredicataRepresentation
gap> NamesOfPredicataRepresentation(P);
[ "MyEqual", "MyAdd" ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="AritiesOfPredicatonRepresentation" Arg="P"/>
<Description>
The function <C>AritiesOfPredicatonRepresentation</C> returns the arities of <A>P</A>.
<Example><![CDATA[
gap> # Continued example: PredicataRepresentation
gap> AritiesOfPredicataRepresentation(P);
[ 2, 3 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="PredicataOfPredicataRepresentation" Arg="P"/>
<Description>
The function <C>PredicataOfPredicataRepresentation</C> returns the automaton of <A>P</A>.
<Example><![CDATA[
gap> # Continued example: PredicataRepresentation
gap> PredicataOfPredicataRepresentation(P);
[ < Predicaton: deterministic finite automaton on 4 letters with 2 states
 and the variable position list [ 1, 2 ]. >,
  < Predicaton: deterministic finite automaton on 8 letters with 3 states 
  and the variable position list [ 1, 2, 3 ]. > ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="ElementOfPredicataRepresentation" Arg="P, i"/>
<Description>
The function <C>ElementOfPredicataRepresentation</C> returns the <A>i</A>-th element as a <Ref Func="PredicatonRepresentation"/>.
<Example><![CDATA[
gap> # Continued example: PredicataRepresentation
gap> ElementOfPredicataRepresentation(P, 1);
< Predicaton represented with the name "MyEqual", the arity 2 and 
the deterministic automaton on 4 letters and 2 states. >
]]></Example>
</Description>
</ManSection>

<ManSection>
<Meth Name="Add" Arg="P, p" Label="PredicataRepresenation"/>
<Description>
The method <C>Add</C> adds the <C>PredicatonRepresentation</C> <A>p</A> to <A>P</A>.
<Example><![CDATA[
gap> # Continued example: PredicataRepresentation
gap> A3:=Predicaton(Automaton("det", 2, [ [ 0 ], [ 1 ] ], [ [ 1, 2 ], [ 2, 2 ] ], 
> [ 1 ], [ 2 ]), [ 1 ]);;
gap> p3:=PredicatonRepresentation("GreaterZero", 1, A3);;
gap> Add(P, p3);
gap> P;
< PredicataRepresentation containing the following predicates: 
[ "MyEqual", "MyAdd", "GreaterZero" ]. >
]]></Example>
</Description>
</ManSection>

<ManSection>
<Meth Name="Add" Arg="P, name, arity, automaton" Label="PredicataRepresenation (variant 2)"/>
<Description>
The method <C>Add</C> adds the <C>PredicatonRepresentation</C> created from <A>name</A>, <A>arity</A> and <A>automaton</A> to <A>P</A>.
<Example><![CDATA[
gap> # Continued example: PredicataRepresentation
gap> A4:=Predicaton(Automaton("det", 2, [ [ 0 ], [ 1 ] ], [ [ 1, 2 ], [ 2, 2 ] ], 
> [ 1 ], [ 1 ]), [ 1 ]);;
gap> Add(P, "EqualZero", 1, A4);
gap> P;
< PredicataRepresentation containing the following predicates: 
[ "MyEqual", "MyAdd", "GreaterZero", "EqualZero" ]. >
]]></Example>
</Description>
</ManSection>

<ManSection>
<Meth Name="Remove" Arg="P, i" Label="PredicataRepresenation"/>
<Description>
The method <C>Remove</C> removes the <A>i</A>-th element of <A>P</A>.
<Example><![CDATA[
gap> A5:=Predicaton(Automaton("det", 4, [ [ 0 ], [ 1 ] ], [ [ 4, 2, 3, 3 ],
> [ 3, 3, 3, 2 ] ], [ 1 ], [ 3, 4, 1 ]), [ 1 ]);;
gap> p5:=PredicatonRepresentation("NotTwo", 1, A5);;
gap> Add(P, p5);
gap> P;
< PredicataRepresentation containing the following predicates: 
[ "NotTwo", "MyEqual", "MyAdd", "GreaterZero", "EqualZero" ]. >
gap> Remove(P, 1);
< Predicaton represented with the name "NotTwo", the arity 1 and 
the deterministic automaton on 2 letters and 4 states. >
gap> P;
< PredicataRepresentation containing the following predicates: 
[ "MyEqual", "MyAdd", "GreaterZero", "EqualZero" ]. >
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="CopyPredicataRepresentation" Arg="P"/>
<Description>
The function <C>CopyPredicataRepresentation</C> copies the <C>PredicataRepresentation</C> <A>P</A>.
<Example><![CDATA[
gap> A:=Predicaton(Automaton("det", 3, [ [ 0, 0 ], [ 1, 0 ], [ 0, 1 ], [ 1, 1 ] ],
> [ [ 1, 3, 3 ], [ 2, 3, 3 ], [ 3, 1, 3 ], [ 3, 2, 3 ] ], [ 1 ], [ 1 ]), [ 1, 2 ]);;
gap> p:=PredicatonRepresentation("CopyPred", 2, A);;
gap> P:=PredicataRepresentation(p);
< PredicataRepresentation containing the following predicates: [ "CopyPred" ]. >
gap> Q:=CopyPredicataRepresentation(P);
< PredicataRepresentation containing the following predicates: [ "CopyPred" ]. >
]]></Example>
</Description>
</ManSection>

<ManSection>
<Var Name="PredicataList" />
<Description>
The variable <C>PredicataList</C> is a <Ref Func="PredicataRepresentation"/> which is called on default by the <Ref Func="PredicataFormula"/>. Together with the functions <Ref Func="AddToPredicataList"/> and <Ref Func="RemoveFromPredicataList"/> the intention is to be able to use own predicates without specifying to much.
<Example><![CDATA[
gap> PredicataList;
< PredicataRepresentation containing the following predicates: [  ]. >
gap> A1:=Predicaton(Automaton("det", 3, [ [ 0, 0, 0 ], [ 1, 0, 0 ], [ 0, 1, 0 ], 
> [ 1, 1, 0 ], [ 0, 0, 1 ], [ 1, 0, 1 ], [ 0, 1, 1 ], [ 1, 1, 1 ] ], 
> [ [ 1, 3, 3 ], [ 3, 2, 3 ], [ 3, 2, 3 ], [ 2, 3, 3 ], [ 3, 1, 3 ], 
> [ 1, 3, 3 ], [ 1, 3, 3 ], [ 3, 2, 3 ] ], [ 1 ], [ 1 ]), [ 1, 2, 3 ]);;
gap> p1:=PredicatonRepresentation("MyAdd", 3, A1);;
gap> Add(PredicataList, p1);
gap> PredicataList;
< PredicataRepresentation containing the following predicates: [ "MyAdd" ]. >
gap> f:=PredicataFormula("MyAdd[x,y,z]");
< PredicataFormula: MyAdd [ x , y , z ] >
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="AddToPredicataList" Arg="p, [arity, automaton]"/>
<Description>
The function <C>AddToPredicataList</C> adds either a <C>PredicatonRepresentation</C> <A>p</A> or the created one with <A>p</A> being a string (<C>name</C>) as well as the <A>arity</A> and the <A>automaton</A> to <C>PredicataList</C>.
<Example><![CDATA[
gap> # Continued example: PredicataList
gap> A2:=Predicaton(Automaton("det", 2, [ [ 0, 0 ], [ 1, 0 ], [ 0, 1 ], [ 1, 1 ] ],
> [ [ 1, 2 ], [ 2, 2 ], [ 2, 2 ], [ 1, 2 ] ], [ 1 ], [ 1 ]), [ 1, 2 ]);;
gap> p2:=PredicatonRepresentation("MyEqual", 2, A2);;
gap> AddToPredicataList(p2);
gap> A3:=Predicaton(Automaton("det", 2, [ [ 0 ], [ 1 ] ], [ [ 1, 2 ], [ 2, 2 ] ], 
> [ 1 ], [ 2 ]), [ 1 ]);;
gap> AddToPredicataList("GreaterZero", 1, A3);
gap> PredicataList;
gap> f:=PredicataFormula("MyAdd[x,y,z] and MyEqual[x,y]");
< PredicataFormula: MyAdd [ x , y , z ] and MyEqual [ x , y ] >
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="ClearPredicataList" Arg=""/>
<Description>
The function <C>ClearPredicataList</C> clears the <C>PredicataList</C>.
<Example><![CDATA[
gap> # Continued example: PredicataList
gap> ClearPredicataList();
gap> PredicataList;
< PredicataRepresentation containing the following predicates: [ ]. >
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="RemoveFromPredicataList" Arg="i"/>
<Description>
The function <C>RemoveFromPredicataList</C> removes the <A>i</A>-th element of the <C>PredicataList</C>.
<Example><![CDATA[
gap> A:=Predicaton(Automaton("det", 4, [ [ 0 ], [ 1 ] ], [ [ 4, 2, 3, 3 ],
> [ 3, 3, 3, 2 ] ], [ 1 ], [ 3, 4, 1 ]), [ 1 ]);;
gap> AddToPredicataList("NotTwo", 1, A);
gap> PredicataList;
< PredicataRepresentation containing the following predicates: [ "NotTwo" ]. >
gap> RemoveFromPredicataList(1);
gap> PredicataList;
< PredicataRepresentation containing the following predicates: [ ]. >
]]></Example>
</Description>
</ManSection>

</Section>

<Section><Heading>Converting PredicataFormulas via PredicataTrees into Predicata</Heading>

<ManSection>
<Func Name = "PredicataFormulaToPredicaton" Arg = "f,[ V]"/>
<Description>
The function <C>PredicataFormulaToPredicaton</C> takes a <Ref Func = "PredicataFormula"/> <A>f</A> and returns a <C>Predicata</C> which language recognizes the solutions of formula <A>f</A>. The input <A>f</A> must be a first-order formula containing the operations addition<M>+</M> and the constant multiplication <M>*</M> (as a shortcut), see <Ref Func="PredicataGrammar"/>. The optional parameter <A>V</A> (list containing strings) allows to set an order of the free variables occurring in <A>f</A>. Note that the variables must not necessarily occur in the formula (for example <C>x = 4</C> and <C>V:=&leftsquare;"x","y"&rightsquare;</C>). 
<Example><![CDATA[
gap> f:=PredicataFormula("x = 4");
< PredicataFormula: x = 4 >
gap> A:=PredicataFormulaToPredicaton(f);
Predicata: deterministic finite automaton on 2 letters with 5 states, 
the variable position list [ 1 ] and the following transitions:
         |  1  2  3  4  5  
---------------------------
  [ 0 ]  |  4  2  2  3  5  
  [ 1 ]  |  2  2  5  2  2  
 Initial states: [ 1 ]
 Final states:   [ 5 ]

 The alphabet corresponds to the following variable list: [ "x" ].

 Regular expression of the automaton:
   [ 0 ][ 0 ][ 1 ][ 0 ]*

 Output:
< Predicata: deterministic finite automaton on 2 letters with 5 states 
and the variable position list [ 1 ]. >
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name = "StringToPredicaton" Arg = "f,[ V]"/>
<Description>
The function <C>StringToPredicaton</C> is the simpler version of <Ref Func = "PredicataFormulaToPredicaton"/>, it takes an <C>String</C> <A>f</A>, converts it to a <C>PredicataFormula</C> and returns a <C>Predicata</C>. The optional parameter <A>V</A> allows to set an order for the variables.
<Example><![CDATA[
gap> A:=StringToPredicaton("x+y = z");
Predicata: deterministic finite automaton on 8 letters with 3 states, 
the variable position list [ 1, 2, 3 ] and the following transitions:
               |  1  2  3  
---------------------------
  [ 0, 0, 0 ]  |  1  3  3  
  [ 1, 0, 0 ]  |  3  2  3  
  [ 0, 1, 0 ]  |  3  2  3  
  [ 1, 1, 0 ]  |  2  3  3  
  [ 0, 0, 1 ]  |  3  1  3  
  [ 1, 0, 1 ]  |  1  3  3  
  [ 0, 1, 1 ]  |  1  3  3  
  [ 1, 1, 1 ]  |  3  2  3  
 Initial states: [ 1 ]
 Final states:   [ 1 ]

 The alphabet corresponds to the following variable list: [ "x", "y", "z" ].

 Regular expression of the automaton:
   ([ 1, 1, 0 ]([ 1, 0, 0 ]U[ 0, 1, 0 ]U[ 1, 1, 1 ])*
   [ 0, 0, 1 ]U[ 0, 0, 0 ]U[ 1, 0, 1 ]U[ 0, 1, 1 ])*

 Output:
< Predicata: deterministic finite automaton on 8 letters with 3 states 
and the variable position list [ 1, 2, 3 ]. >
]]></Example>
</Description>
</ManSection>

</Section>

</Chapter>
