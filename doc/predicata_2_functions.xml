<?xml version="1.0" encoding="UTF-8"?>
<Chapter Label="Functions"><Heading>Creating Predicata</Heading>

<Section><Heading>Predicaton &#8211; an extended finite automaton</Heading>

<ManSection>
<Func Name="Predicaton" Arg="Automaton, VariablePositionList" Label="Automaton with variable position list"/>
<Description>
A <C>Predicaton</C> represents a first-order formulas, with <M>n</M> free variables, containing the nullary operations <M>0</M> and <M>1</M> and the binary operation <M>+</M>.
It consists of an <C>Automaton</C> and a <C>VariablePositionList</C>.
<P/>
The first parameter is an <A>Automaton</A> from the package &Automata;, which is created as follows: <C>Automaton(Type, Size, Alphabet, TransitionTable, Initial, Final)</C>. 
In order to create a <C>Predicaton</C> the <A>Type</A> must either be <C>"det"</C> or <C>"nondet"</C>. 
The <A>Size</A> is a positive integer giving the number of states. 
The <A>Alphabet</A> must be a list of length <M>2^n</M>, i.e. the list of all n-tuples <M>\{0,1\}^n</M>. 
The <A>TransitionTable</A> gives the transition matrix, where the entry at <M>(i,j)</M> denotes the state reached with the <M>i</M>-th letter (<M>i</M>-th row) and the <M>j</M>-th state (<M>j</M>-th column). The <A>Initial</A> and <A>Final</A> are the initial and final state sets. 
<P/>
The second parameter <A>VariablePositionList</A> must be of length <M>n</M> and must contain <M>n</M> pairwise distinct positive integers. 
It internally represents the occurring variables in the first-order formula by assigning pairwise distinct natural numbers to each free variable.
The <A>VariablePositionList</A> coincides with the letters, i.e. the <M>i</M>-th position in the <M>n</M>-tuples correspond to the variable position at the <M>i</M>-th position in the list.
<P/>
A word over the alphabet <M>\{0,1\}^n</M> can be turned into <M>n</M> reversed binary representations of natural numbers by extracting the components of the letters.
The <M>i</M>-th row of a word (choosing the <M>i</M>-th component of each letter) corresponds to the <M>i</M>-th entry in the <A>VariablePositionList</A>.
The accepted words of the automaton represent those <M>n</M> natural numbers, such that upon interpretation the first-order formula is satisfied.
<P/>
In the following example the <C>Automaton A</C> represents the formula <M>x+y=z</M> with the following variables: the variable <M>x</M> is assigned to <M>1</M>, the variable <M>y</M> is assigned to <M>2 </M> and the variable <M>z</M> is assigned to <M>3</M>
The <C>Predicaton P</C> is created with the deterministic finite automaton <C>A</C> and the variable position list <C>[ 1, 2, 3 ]</C>. 
This means the first entry in the letters corresponds to the variable with the assigned natural number 1, i.e. <M>x</M>, the second entry to the number <M>2</M>, i.e. the variable <M>y</M> and the third entry to the number <M>3</M>, i.e. the variable <M>z</M>. 
<P/>
Later also a mathematically more intuitive method is introduced, see <Ref Meth="Predicaton" Label="PredicataFormula"/> for creating a <C>Predicaton</C> from a first-order formula.
<Example><![CDATA[
gap> A:=Automaton("det", 3,
> [ [ 0, 0, 0 ], [ 1, 0, 0 ], [ 0, 1, 0 ], [ 1, 1, 0 ],
> [ 0, 0, 1 ], [ 1, 0, 1 ], [ 0, 1, 1 ], [ 1, 1, 1 ] ],
> [ [ 1, 3, 3 ], [ 3, 2, 3 ], [ 3, 2, 3 ], [ 2, 3, 3 ],
> [ 3, 1, 3 ], [ 1, 3, 3 ], [ 1, 3, 3 ], [ 3, 2, 3 ] ],
> [ 1 ], [ 1 ]);
< deterministic automaton on 8 letters with 3 states >
gap> P:=Predicaton( A, [ 1, 2, 3 ]);
< Predicaton: deterministic finite automaton on 8 letters with 3 states 
and the variable position list [ 1, 2, 3 ]. >
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="BuildPredicaton" Arg="Type, Size, Alphabet, TransitionTable, Initial, Final, VariablePositionList"/>
<Description>
The function <C>BuildPredicaton</C> allows the creation of a <C>Predicaton</C> without specifying an <C>Automaton</C>.
<Example><![CDATA[
gap> P:=BuildPredicaton("det", 3, [ [ 0, 0, 0 ], [ 1, 0, 0 ], [ 0, 1, 0 ],
> [ 1, 1, 0 ], [ 0, 0, 1 ], [ 1, 0, 1 ], [ 0, 1, 1 ], [ 1, 1, 1 ] ],
> [ [ 1, 3, 3 ], [ 3, 2, 3 ], [ 3, 2, 3 ], [ 2, 3, 3 ], [ 3, 1, 3 ],
> [ 1, 3, 3 ], [ 1, 3, 3 ], [ 3, 2, 3 ] ], [ 1 ], [ 1 ], [ 1, 2, 3 ]);
< Predicaton: deterministic finite automaton on 8 letters with 3 states 
and the variable position list [ 1, 2, 3 ]. >
gap> Display(P);
Predicaton: deterministic finite automaton on 8 letters with 3 states, 
the variable position list [ 1, 2, 3 ] and the following transitions:
               |  1  2  3  
---------------------------
  [ 0, 0, 0 ]  |  1  3  3  
  [ 1, 0, 0 ]  |  3  2  3  
  [ 0, 1, 0 ]  |  3  2  3  
  [ 1, 1, 0 ]  |  2  3  3  
  [ 0, 0, 1 ]  |  3  1  3  
  [ 1, 0, 1 ]  |  1  3  3  
  [ 0, 1, 1 ]  |  1  3  3  
  [ 1, 1, 1 ]  |  3  2  3  
 Initial states: [ 1 ]
 Final states:   [ 1 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="IsPredicaton" Arg="P"/>
<Description>
The function <C>IsPredicaton</C> checks if <A>P</A> is a <C>Predicaton</C>.
<Example><![CDATA[
gap> P:=BuildPredicaton("det", 2, [ [ 0, 0 ], [ 1, 0 ], [ 0, 1 ], [ 1, 1 ] ],
> [ [ 1, 2 ], [ 2, 2 ], [ 2, 2 ], [ 1, 2 ] ], [ 1 ], [ 1 ], [ 1, 2 ]);
< Predicaton: deterministic finite automaton on 4 letters with 2 states 
and the variable position list [ 1, 2 ]. >
gap> IsPredicaton(P);
true
]]></Example>
</Description>
</ManSection>

<ManSection>
<Meth Name="Display" Arg="P" Label="Predicaton"/>
<Description>
The method <C>Display</C> prints the transition table of the <C>Predicaton</C> <A>P</A>. The left side are the letters of the alphabet, the top row are the states and the transition from the <M>i</M>-th letter (row) and <M>j</M>-th state (column) is the entry <M>(i,j)</M>.
<Example><![CDATA[
gap> P:=Predicaton(Automaton("det", 3, [ [ 0, 0, 0 ], [ 1, 0, 0 ], [ 0, 1, 0 ],
> [ 1, 1, 0 ], [ 0, 0, 1 ], [ 1, 0, 1 ], [ 0, 1, 1 ], [ 1, 1, 1 ] ],
> [ [ 1, 3, 3 ], [ 3, 2, 3 ], [ 3, 2, 3 ], [ 2, 3, 3 ], [ 3, 1, 3 ],
> [ 1, 3, 3 ], [ 1, 3, 3 ], [ 3, 2, 3 ] ], [ 1 ], [ 1 ]), [ 1, 2, 3 ]);
< Predicaton: deterministic finite automaton on 8 letters with 3 states 
and the variable position list [ 1, 2, 3 ]. >
gap> Display(P);
Predicaton: deterministic finite automaton on 8 letters with 3 states, 
the variable position list [ 1, 2, 3 ] and the following transitions:
               |  1  2  3  
---------------------------
  [ 0, 0, 0 ]  |  1  3  3  
  [ 1, 0, 0 ]  |  3  2  3  
  [ 0, 1, 0 ]  |  3  2  3  
  [ 1, 1, 0 ]  |  2  3  3  
  [ 0, 0, 1 ]  |  3  1  3  
  [ 1, 0, 1 ]  |  1  3  3  
  [ 0, 1, 1 ]  |  1  3  3  
  [ 1, 1, 1 ]  |  3  2  3  
 Initial states: [ 1 ]
 Final states:   [ 1 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Meth Name="View" Arg="P" Label="Predicaton"/>
<Description>
The method <C>View</C> applied on a <C>Predicaton</C> <A>P</A> returns the object text.
<Example><![CDATA[
gap> P:=Predicaton(Automaton("det", 3, [ [ 0 ], [ 1 ] ], [ [ 2, 2, 3 ],
> [ 3, 2, 2 ] ], [ 1 ], [ 3 ]), [ 1 ]);;
gap> View(P);
< Predicaton: deterministic finite automaton on 2 letters with 3 states 
and the variable position list [ 1 ]. >
]]></Example>
</Description>
</ManSection>

<ManSection>
<Meth Name="Print" Arg="P" Label="Predicaton"/>
<Description>
The method <C>Print</C> applied on a <C>Predicaton</C> <A>P</A> prints the input as a string.
<Example><![CDATA[
gap> P:=Predicaton(Automaton("det", 3, [ [ 0, 0 ], [ 1, 0 ], [ 0, 1 ], [ 1, 1 ] ], 
> [ [ 1, 3, 3 ], [ 2, 3, 3 ], [ 3, 1, 3 ], [ 3, 2, 3 ] ], [ 1 ], [ 1 ]), 
> [ 1, 2 ]);;
gap> Print(P);
Predicaton(Automaton("det", 3, [ [ 0, 0 ], [ 1, 0 ], [ 0, 1 ], [ 1, 1 ] ], [ [ \
1, 3, 3 ], [ 2, 3, 3 ], [ 3, 1, 3 ], [ 3, 2, 3 ] ], [ 1 ], [ 1 ]), [ 1, 2 ]);;
gap> String(P);
"Predicaton(Automaton(\"det\", 3, [ [ 0, 0 ], [ 1, 0 ], [ 0, 1 ], [ 1, 1 ] ], [ [\
1, 3, 3 ], [ 2, 3, 3 ], [ 3, 1, 3 ], [ 3, 2, 3 ] ], [ 1 ], [ 1 ]), [ 1, 2 ]);;"
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="GetAlphabet" Arg="n"/>
<Description>
The function <C>GetAlphabet</C> returns the alphabet <M>A^n</M> for <M>A:=\{0,1\}</M>.
<Example><![CDATA[
gap> a1:=GetAlphabet(3);
[ [ 0, 0, 0 ], [ 1, 0, 0 ], [ 0, 1, 0 ], [ 1, 1, 0 ], 
  [ 0, 0, 1 ], [ 1, 0, 1 ], [ 0, 1, 1 ], [ 1, 1, 1 ] ]
gap> P1:=Predicaton(Automaton("det", 3, a1,
> [ [ 1, 3, 3 ], [ 3, 2, 3 ], [ 3, 2, 3 ], [ 2, 3, 3 ], [ 3, 1, 3 ],
> [ 1, 3, 3 ], [ 1, 3, 3 ], [ 3, 2, 3 ] ], [ 1 ], [ 1 ]), [ 1, 2, 3 ]);;
gap> Display(P1);
Predicaton: deterministic finite automaton on 8 letters with 3 states, 
the variable position list [ 1, 2, 3 ] and the following transitions:
               |  1  2  3  
---------------------------
  [ 0, 0, 0 ]  |  1  3  3  
  [ 1, 0, 0 ]  |  3  2  3  
  [ 0, 1, 0 ]  |  3  2  3  
  [ 1, 1, 0 ]  |  2  3  3  
  [ 0, 0, 1 ]  |  3  1  3  
  [ 1, 0, 1 ]  |  1  3  3  
  [ 0, 1, 1 ]  |  1  3  3  
  [ 1, 1, 1 ]  |  3  2  3  
 Initial states: [ 1 ]
 Final states:   [ 1 ]
gap> a2:=GetAlphabet(0);
[ [  ] ]
gap> P2:=Predicaton(Automaton("det", 1, a2, [ [ 1 ] ], [ 1 ], [ 1 ]), [ ]);;
gap> Display(P2);
Predicaton: deterministic finite automaton on 1 letter with 1 state, 
the variable position list [ ] and the following transitions:
       |  1  
-------------
  [ ]  |  1  
 Initial states: [ 1 ]
 Final states:   [ 1 ]
]]></Example>
</Description>
</ManSection>

</Section>

<Section Label="Functions on Automata and Predicata"><Heading>Basic functions on Automata and Predicata</Heading>
The package &Automata; allows lists of lists as input for the alphabet, but unfortunately is lacking in further support. The functions regarding the alphabet takes only <C>ShallowCopy</C> whereas a list of lists <C>StructuralCopy</C> is needed, as well as the method <C>Display</C> for automata prints with some weird spacing. Therefore this package reintroduces the basic &Automata; functions with another name to ensure full control. Nevertheless all credit belongs to the creators of the package &Automata;.
<P/>
Note that the <C>Predicata</C> in the following examples corresponds to first-order formulas. The accepted natural numbers can be displayed with the functions from section <Ref Sect="Functions On Predicata"/>.
<P/>
Furthermore, note that the following functions can be either called with an <C>Automaton</C> or a <C>Predicaton</C>.

<ManSection>
<Func Name="DisplayAut" Arg="P"/>
<Description>
The function <C>DisplayAut</C> prints the <C>Automaton</C> or <C>Predicaton</C> <A>P</A> (called by <Ref Meth="Display" Label="Predicaton"/>).
<Example><![CDATA[
gap> A:=Automaton("det", 4, [ [ 0, 0 ], [ 1, 0 ], [ 0, 1 ], [ 1, 1 ] ],
> [ [ 3, 2, 2, 4 ], [ 2, 2, 4, 2 ], [ 2, 2, 3, 2 ], [ 3, 2, 2, 4 ] ],
> [ 1 ], [ 4 ]);
< deterministic automaton on 4 letters with 4 states >
gap> DisplayAut(A);
deterministic finite automaton on 4 letters with 4 states 
and the following transitions:
            |  1  2  3  4  
---------------------------
  [ 0, 0 ]  |  3  2  2  4  
  [ 1, 0 ]  |  2  2  4  2  
  [ 0, 1 ]  |  2  2  3  2  
  [ 1, 1 ]  |  3  2  2  4  
 Initial states: [ 1 ]
 Final states:   [ 4 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="DrawPredicaton" Arg="P"/>
<Description>
The function <C>DrawPredicaton</C> calls the function <C>DrawAutomaton</C> from the package &Automata; which uses
    <C>graphviz</C> <Cite Key="KoutsofiosNorth:2002"/>, a software for drawing graphs developed at AT
    <Alt Only="LaTeX">
      \&#38;
    </Alt>
    <Alt Not="LaTeX">
      <Alt Only="HTML">
        &#38;amp;
      </Alt>
      <Alt Not="HTML">
        &#38;
      </Alt>
    </Alt>
    T Labs, that can be obtained at
    <URL>http://www.graphviz.org/</URL>. For further details please refer to the manual of the package &Automata;.
<Example><![CDATA[
gap> A:=Automaton("det", 4, [ [ 0, 0 ], [ 1, 0 ], [ 0, 1 ], [ 1, 1 ] ],
> [ [ 3, 2, 2, 4 ], [ 2, 2, 4, 2 ], [ 2, 2, 3, 2 ], [ 3, 2, 2, 4 ] ],
> [ 1 ], [ 4 ]);
< deterministic automaton on 4 letters with 4 states >
gap> DisplayAut(A);
deterministic finite automaton on 4 letters with 4 states 
and the following transitions:
            |  1  2  3  4  
---------------------------
  [ 0, 0 ]  |  3  2  2  4  
  [ 1, 0 ]  |  2  2  4  2  
  [ 0, 1 ]  |  2  2  3  2  
  [ 1, 1 ]  |  3  2  2  4  
 Initial states: [ 1 ]
 Final states:   [ 4 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="IsDeterministicAut" Arg="P"/>
<Description>
The function <C>IsDeterministicAut</C> checks if the <C>Type</C> of an <C>Automaton</C> or a <C>Predicaton</C> <A>P</A> is <C>"det"</C>. If yes then <K>true</K>, otherwise <K>false</K>.
<Example><![CDATA[
gap> P:=Predicaton(Automaton("det", 5, [ [ 0 ], [ 1 ] ], [ [ 1, 2, 2, 3, 2 ], 
> [ 2, 2, 1, 2, 4 ] ], [ 5 ], [ 1 ]), [ 1 ]);
< Predicaton: deterministic finite automaton on 2 letters with 5 states 
and the variable position list [ 1 ]. >
gap> IsDeterministicAut(P);
true
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="IsNonDeterministicAut" Arg="P"/>
<Description>
The function <C>IsNonDeterministicAut</C> checks if the <C>Type</C> of an <C>Automaton</C> or a <C>Predicaton</C> <A>P</A> is <C>"nondet"</C>. If yes then <K>true</K>, otherwise <K>false</K>.
<Example><![CDATA[
gap> P:=Predicaton(Automaton("nondet", 2, [ [ 0 ], [ 1 ] ], [ [ 1  ], [  ] ],
> [ 1 ], [ 1 ]), [ 1 ]);
< Predicaton: nondeterministic finite automaton on 2 letters with 2 states 
and the variable position list [ 1 ]. >
gap> Display(P);
Predicaton: nondeterministic finite automaton on 2 letters with 2 states, 
the variable position list [ 1 ] and the following transitions:
         |  1      2      
--------------------------
  [ 0 ]  |  [ 1 ]  [ ]    
  [ 1 ]  |  [ ]    [ ]    
 Initial states: [ 1 ]
 Final states:   [ 1 ]
gap> IsNonDeterministicAut(P);
true
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="TypeOfAut" Arg="P"/>
<Description>
The function <C>TypeOfAut</C> returns the <C>Type</C> of an <C>Automaton</C> or a <C>Predicaton</C> <A>P</A>, either <C>"det"</C>, <C>"nondet"</C> or <C>"epsilon"</C>. Note that a <C>Predicaton</C> can only be a deterministic or nondeterministic finite automaton.
<Example><![CDATA[
gap> P:=Predicaton(Automaton("det", 5, [ [ 0, 0 ], [ 1, 0 ], [ 0, 1 ], [ 1, 1 ] ], 
> [ [ 2, 2, 2, 2, 5 ], [ 2, 2, 5, 2, 2 ], [ 2, 2, 2, 3, 2 ], [ 4, 2, 2, 2, 2 ] ],
> [ 1 ], [ 5 ]), [ 1, 2 ]);;
gap> TypeOfAut(P);
"det"
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="AlphabetOfAut" Arg="P"/>
<Description>
The function <C>AlphabetOfAut</C> returns the size of an <C>Alphabet</C> of an <C>Automaton</C> or a <C>Predicaton</C> <A>P</A>.
<Example><![CDATA[
gap> P:=Predicaton(Automaton("det", 2, [ [ 0, 0 ], [ 1, 0 ], [ 0, 1 ], [ 1, 1 ] ], 
> [ [ 1, 2 ], [ 2, 2 ], [ 2, 2 ], [ 1, 2 ] ], [ 1 ], [ 1 ]), [ 1, 2 ]);;
gap> AlphabetOfAut(P);
4
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="AlphabetOfAutAsList" Arg="P"/>
<Description>
The function <C>AlphabetOfAutAsList</C> returns a <C>StructuralCopy</C> of the <C>Alphabet</C> of an <C>Automaton</C> or a <C>Predicaton</C> <A>P</A>.
<Example><![CDATA[
gap> # Continued 
gap> AlphabetOfAutAsList(P);
[ [ 0, 0 ], [ 1, 0 ], [ 0, 1 ], [ 1, 1 ] ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="NumberStatesOfAut" Arg="P"/>
<Description>
The function <C>NumberStatesOfAut</C> returns the number of the <C>States</C> of an <C>Automaton</C> or a <C>Predicaton</C> <A>P</A>.
<Example><![CDATA[
gap> P:=Predicaton(Automaton("det", 5, [ [ 0, 0 ], [ 1, 0 ], [ 0, 1 ], [ 1, 1 ] ],
> [ [ 2, 2, 2, 2, 5 ], [ 4, 2, 5, 3, 2 ], [ 4, 2, 5, 3, 2 ], [ 2, 2, 2, 2, 2 ] ], 
> [ 1 ], [ 5 ]), [ 1, 2 ]);;
gap> NumberStatesOfAut(P);
5
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="SortedStatesAut" Arg="P"/>
<Description>
The function <C>SortedStatesAut</C> returns the <C>Automaton</C> or the <C>Predicaton</C> <A>P</A> with sorted <C>States</C>, such that the initial states have the lowest and the final states the highest number.
<Example><![CDATA[
gap> P:=Predicaton(Automaton("det", 5, [ [ 0 ], [ 1 ] ], [ [ 1, 2, 2, 2, 2 ],
> [ 2, 2, 1, 3, 4 ] ], [ 5 ], [ 1 ]), [ 1 ]);;
gap> Display(P);
Predicaton: deterministic finite automaton on 2 letters with 5 states, 
the variable position list [ 1 ] and the following transitions:
         |  1  2  3  4  5  
---------------------------
  [ 0 ]  |  1  2  2  2  2  
  [ 1 ]  |  2  2  1  3  4  
 Initial states: [ 5 ]
 Final states:   [ 1 ]
gap> S:=SortedStatesAut(P);;
gap> Display(S);
Predicaton: deterministic finite automaton on 2 letters with 5 states, 
the variable position list [ 1 ] and the following transitions:
         |  1  2  3  4  5  
---------------------------
  [ 0 ]  |  2  2  2  2  5  
  [ 1 ]  |  4  2  5  3  2  
 Initial states: [ 1 ]
 Final states:   [ 5 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="TransitionMatrixOfAut" Arg="P"/>
<Description>
The function <C>TransitionMatrixOfAut</C> returns a <C>StructuralCopy</C> of the <C>TransitionMatrix</C> of an <C>Automaton</C> or a <C>Predicaton</C> <A>P</A>.
<Example><![CDATA[
gap> P:=Predicaton(Automaton("det", 5, [ [ 0 ], [ 1 ] ], [ [ 1, 2, 2, 2, 2 ],
> [ 2, 2, 1, 3, 4 ] ], [ 5 ], [ 1 ]), [ 1 ]);;
gap> Display(P);
Predicaton: deterministic finite automaton on 2 letters with 5 states, 
the variable position list [ 1 ] and the following transitions:
         |  1  2  3  4  5  
---------------------------
  [ 0 ]  |  1  2  2  2  2  
  [ 1 ]  |  2  2  1  3  4  
 Initial states: [ 5 ]
 Final states:   [ 1 ]
gap> TransitionMatrixOfAut(P);
[ [ 1, 2, 2, 2, 2 ], [ 2, 2, 1, 3, 4 ] ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="InitialStatesOfAut" Arg="P"/>
<Description>
The function <C>InitialStatesOfAut</C> returns the <C>Initial</C> states of an <C>Automaton</C> or a <C>Predicaton</C> <A>P</A>.
<Example><![CDATA[
gap> P:=Predicaton(Automaton("det", 5, [ [ 0 ], [ 1 ] ], [ [ 2, 2, 2, 3, 5 ], 
> [ 4, 2, 5, 2, 2 ] ], [ 1 ], [ 5 ]), [ 1 ]);;
gap> InitialStatesOfAut(P);
[ 1 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="SetInitialStatesOfAut" Arg="P"/>
<Description>
The function <C>SetInitialStatesOfAut</C> sets the <C>Initial</C> states of an <C>Automaton</C> or a <C>Predicaton</C> <A>P</A>.
<Example><![CDATA[
gap> P:=Predicaton(Automaton("det", 5, [ [ 0 ], [ 1 ] ], [ [ 2, 2, 2, 3, 5 ],
> [ 4, 2, 5, 2, 2 ] ], [ 1 ], [ 5 ]), [ 1 ]);;
gap> Display(P);
Predicaton: deterministic finite automaton on 2 letters with 5 states, 
the variable position list [ 1 ] and the following transitions:
         |  1  2  3  4  5  
---------------------------
  [ 0 ]  |  2  2  2  3  5  
  [ 1 ]  |  4  2  5  2  2  
 Initial states: [ 1 ]
 Final states:   [ 5 ]
gap> SetInitialStatesOfAut(P, 3);
gap> Display(P);
Predicaton: deterministic finite automaton on 2 letters with 5 states, 
the variable position list [ 1 ] and the following transitions:
         |  1  2  3  4  5  
---------------------------
  [ 0 ]  |  2  2  2  3  5  
  [ 1 ]  |  4  2  5  2  2  
 Initial states: [ 3 ]
 Final states:   [ 5 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="FinalStatesOfAut" Arg="P"/>
<Description>
The function <C>FinalStatesOfAut</C> returns the <C>Final</C> states of an <C>Automaton</C> or a <C>Predicaton</C> <A>P</A>.
<Example><![CDATA[
gap> P:=Predicaton(Automaton("det", 4, [ [ 0 ], [ 1 ] ], [ [ 2, 2, 2, 4 ],
> [ 3, 2, 4, 2 ] ], [ 1 ], [ 4 ]), [ 1 ]);;
gap> Display(P);
Predicaton: deterministic finite automaton on 2 letters with 4 states, 
the variable position list [ 1 ] and the following transitions:
         |  1  2  3  4  
------------------------
  [ 0 ]  |  2  2  2  4  
  [ 1 ]  |  3  2  4  2  
 Initial states: [ 1 ]
 Final states:   [ 4 ]
gap> FinalStatesOfAut(P);
[ 4 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="SetFinalStatesOfAut" Arg="P"/>
<Description>
The function <C>SetFinalStatesOfAut</C> sets the <C>Final</C> states of an <C>Automaton</C> or a <C>Predicaton</C> <A>P</A>.
<Example><![CDATA[
gap> P:=Predicaton(Automaton("det", 4, [ [ 0 ], [ 1 ] ], [ [ 2, 2, 2, 4 ],
> [ 3, 2, 4, 2 ] ], [ 1 ], [ 4 ]), [ 1 ]);;
gap> Display(P);
Predicaton: deterministic finite automaton on 2 letters with 4 states, 
the variable position list [ 1 ] and the following transitions:
         |  1  2  3  4  
------------------------
  [ 0 ]  |  2  2  2  4  
  [ 1 ]  |  3  2  4  2  
 Initial states: [ 1 ]
 Final states:   [ 4 ]
gap> SetFinalStatesOfAut(P, [ 1, 2, 3 ]);
gap> Display(P);
Predicaton: deterministic finite automaton on 2 letters with 4 states, 
the variable position list [ 1 ] and the following transitions:
         |  1  2  3  4  
------------------------
  [ 0 ]  |  2  2  2  4  
  [ 1 ]  |  3  2  4  2  
 Initial states: [ 1 ]
 Final states:   [ 1, 2, 3 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="SinkStatesOfAut" Arg="P"/>
<Description>
The function <C>SinkStatesOfAut</C> returns the sink states of an <C>Automaton</C> or a <C>Predicaton</C> <A>P</A>.
<Example><![CDATA[
gap> P:=Predicaton(Automaton("det", 3, [ [ 0 ], [ 1 ] ], [ [ 2, 2, 3 ],
> [ 3, 2, 2 ] ], [ 1 ], [ 3 ]), [ 1 ]);;
gap> Display(P);
Predicaton: deterministic finite automaton on 2 letters with 3 states, 
the variable position list [ 1 ] and the following transitions:
         |  1  2  3  
---------------------
  [ 0 ]  |  2  2  3  
  [ 1 ]  |  3  2  2  
 Initial states: [ 1 ]
 Final states:   [ 3 ]
gap> SinkStatesOfAut(P);
[ 2 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="PermutedStatesAut" Arg="P, p"/>
<Description>
The function <C>PermutedStatesAut</C> permutes the names of the states of an <C>Automaton</C> or a <C>Predicaton</C> <A>P</A>. The list <A>p</A> contains all states, where the state <C>i</C> (i.e. <C>i</C>-th position) is mapped to the state <C>p&leftsquare;i&rightsquare;</C>.
<Example><![CDATA[
gap> P:=Predicaton(Automaton("det", 6, [ [ 0 ], [ 1 ] ], [ [ 5, 2, 2, 3, 4, 6 ],
> [ 2, 2, 6, 2, 2, 2 ] ], [ 1 ], [ 6 ]), [ 1 ]);;
gap> Display(P);
Predicaton: deterministic finite automaton on 2 letters with 6 states, 
the variable position list [ 1 ] and the following transitions:
         |  1  2  3  4  5  6  
------------------------------
  [ 0 ]  |  5  2  2  3  4  6  
  [ 1 ]  |  2  2  6  2  2  2  
 Initial states: [ 1 ]
 Final states:   [ 6 ]
gap> Q:=PermutedStatesAut(P,[1,6,4,3,2,5]);;
gap> Display(Q);
Predicaton: deterministic finite automaton on 2 letters with 6 states, 
the variable position list [ 1 ] and the following transitions:
         |  1  2  3  4  5  6  
------------------------------
  [ 0 ]  |  2  3  4  6  5  6  
  [ 1 ]  |  6  6  6  5  6  6  
 Initial states: [ 1 ]
 Final states:   [ 5 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="CopyAut" Arg="P"/>
<Func Name="CopyPredicaton" Arg="P"/>
<Description>
The function <C>CopyAut</C> copies either the <C>Automaton</C> or the <C>Predicaton</C> <A>P</A>.
<Example><![CDATA[
gap> P:=Predicaton(Automaton("det", 2, [ [ 0 ], [ 1 ] ], [ [ 1, 2 ], [ 2, 2 ] ],
> [ 1 ], [ 1 ]), [ 1 ]);;
gap> C:=CopyAut(P);;
gap> SetFinalStatesOfAut(C, 2);
gap> Display(P);
Predicaton: deterministic finite automaton on 2 letters with 2 states, 
the variable position list [ 1 ] and the following transitions:
         |  1  2  
------------------
  [ 0 ]  |  1  2  
  [ 1 ]  |  2  2  
 Initial states: [ 1 ]
 Final states:   [ 1 ]
gap> Display(C);
Predicaton: deterministic finite automaton on 2 letters with 2 states, 
the variable position list [ 1 ] and the following transitions:
         |  1  2  
------------------
  [ 0 ]  |  1  2  
  [ 1 ]  |  2  2  
 Initial states: [ 1 ]
 Final states:   [ 2 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="MinimalAut" Arg="P"/>
<Description>
The function <C>MinimalAut</C> returns the minimal deterministic finite automaton of an <C>Automaton</C> <A>P</A>. Given a <C>Predicaton</C> <A>P</A> its automaton is minimized and returned as a <C>Predicaton</C> with the same variable position list. 
<Example><![CDATA[
gap> P:=Predicaton(Automaton("det", 9, [ [ 0, 0 ], [ 1, 0 ], [ 0, 1 ], [ 1, 1 ] ],
> [ [ 2, 6, 7, 4, 5, 4, 5, 8, 9 ], [ 3, 6, 6, 4, 4, 4, 4, 8, 8 ],
> [ 4, 4, 5, 4, 5, 8, 9, 4, 5 ], [ 5, 4, 4, 4, 4, 8, 8, 4, 4 ] ],
> [ 1 ], [ 9 ]), [ 1, 2 ]);;
gap> Display(P);
Predicaton: deterministic finite automaton on 4 letters with 9 states, 
the variable position list [ 1, 2 ] and the following transitions:
            |  1  2  3  4  5  6  7  8  9  
------------------------------------------
  [ 0, 0 ]  |  2  6  7  4  5  4  5  8  9  
  [ 1, 0 ]  |  3  6  6  4  4  4  4  8  8  
  [ 0, 1 ]  |  4  4  5  4  5  8  9  4  5  
  [ 1, 1 ]  |  5  4  4  4  4  8  8  4  4  
 Initial states: [ 1 ]
 Final states:   [ 9 ]
gap> M:=MinimalAut(P);;
gap> Display(M);
Predicaton: deterministic finite automaton on 4 letters with 5 states, 
the variable position list [ 1, 2 ] and the following transitions:
            |  1  2  3  4  5  
------------------------------
  [ 0, 0 ]  |  1  2  2  3  2  
  [ 1, 0 ]  |  2  2  2  2  4  
  [ 0, 1 ]  |  2  2  1  2  2  
  [ 1, 1 ]  |  2  2  2  2  2  
 Initial states: [ 5 ]
 Final states:   [ 1 ]
gap> P:=Predicaton(Automaton("nondet", 8, [ [ 0 ], [ 1 ] ],
> [ [ [ 2 ], [ 2 ], [ 2 ], [ 4 ], [ 7 ], [ 6 ], [ 6 ], [ 8 ] ],
> [ [ 3 ], [ 2 ], [ 4 ], [ 2 ], [ 6 ], [ 6 ], [ 8 ], [ 6 ] ] ],
> [ 1, 5 ], [ 4, 8 ]), [ 1 ]);;
gap> M:=MinimalAut(P);;
gap> Display(M);
Predicaton: deterministic finite automaton on 2 letters with 4 states, 
the variable position list [ 1 ] and the following transitions:
         |  1  2  3  4  
------------------------
  [ 0 ]  |  1  2  2  3  
  [ 1 ]  |  2  2  1  3  
 Initial states: [ 4 ]
 Final states:   [ 1 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="NegatedAut" Arg="P"/>
<Description>
The function <C>NegatedAut</C> changes the <C>Final</C> states to non-final ones and the non-final states to <C>Final</C> ones.
<Example><![CDATA[
gap> P:=Predicaton(Automaton("det", 4, [ [ 0 ], [ 1 ] ], [ [ 2, 2, 2, 4 ],
> [ 3, 2, 4, 2 ] ], [ 1 ], [ 4 ]), [ 1 ]);;
gap> Display(P);
Predicaton: deterministic finite automaton on 2 letters with 4 states, 
the variable position list [ 1 ] and the following transitions:
         |  1  2  3  4  
------------------------
  [ 0 ]  |  2  2  2  4  
  [ 1 ]  |  3  2  4  2  
 Initial states: [ 1 ]
 Final states:   [ 4 ]
gap> Q:=NegatedAut(P);;
gap> Display(Q);
Predicaton: deterministic finite automaton on 2 letters with 4 states, 
the variable position list [ 1 ] and the following transitions:
         |  1  2  3  4  
------------------------
  [ 0 ]  |  2  2  2  4  
  [ 1 ]  |  3  2  4  2  
 Initial states: [ 1 ]
 Final states:   [ 1, 2, 3 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="IntersectionAut" Arg="P"/>
<Description>
The function <C>IntersectionAut</C> returns the intersection of two <C>Automata</C> or <C>Predicata</C> <A>P</A>. Note that the for intersection of two automata both must have the same ordered alphabet. For the intersection of two <C>Predicata</C> with different alphabets use <Ref Func="IntersectionPredicata"/>.
<Example><![CDATA[
gap> P1:=Predicaton(Automaton("det", 5, [ [ 0, 0 ], [ 1, 0 ], [ 0, 1 ], [ 1, 1 ] ],
> [ [ 2, 2, 2, 3, 5 ], [ 2, 2, 2, 3, 5 ], [ 4, 2, 5, 2, 2 ], [ 4, 2, 5, 2, 2 ] ],
> [ 1 ], [ 5 ]), [ 1, 2 ]);;
gap> P2:=Predicaton(Automaton("det", 2, [ [ 0, 0 ], [ 1, 0 ], [ 0, 1 ], [ 1, 1 ] ],
> [ [ 1, 2 ], [ 2, 2 ], [ 2, 2 ], [ 1, 2 ] ], [ 1 ], [ 1 ]), [ 1, 2 ]);;
gap> P3:=IntersectionAut(P1, P2);;
gap> Display(P3);
Predicaton: deterministic finite automaton on 4 letters with 9 states, 
the variable position list [ 1, 2 ] and the following transitions:
            |  1  2  3  4  5  6  7  8  9  
------------------------------------------
  [ 0, 0 ]  |  2  2  3  6  7  3  2  8  9  
  [ 1, 0 ]  |  3  3  3  6  6  3  3  8  8  
  [ 0, 1 ]  |  4  3  3  3  3  8  8  3  3  
  [ 1, 1 ]  |  5  2  3  3  2  8  9  3  2  
 Initial states: [ 1 ]
 Final states:   [ 9 ]
gap> P4:=MinimalAut(P3);;
gap> Display(P4);
Predicaton: deterministic finite automaton on 4 letters with 5 states, 
the variable position list [ 1, 2 ] and the following transitions:
            |  1  2  3  4  5  
------------------------------
  [ 0, 0 ]  |  1  2  2  3  2  
  [ 1, 0 ]  |  2  2  2  2  2  
  [ 0, 1 ]  |  2  2  2  2  2  
  [ 1, 1 ]  |  2  2  1  2  4  
 Initial states: [ 5 ]
 Final states:   [ 1 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="UnionAut" Arg="P"/>
<Description>
The function <C>UnionAut</C> returns the union of two <C>Automata</C> or <C>Predicata</C> <A>P</A>. Note that for the union of two automata both must have the same ordered alphabet. For the union of two <C>Predicata</C> with different alphabets use <Ref Func="UnionPredicata"/>.
<Example><![CDATA[
gap> P1:=Predicaton(Automaton("det", 2, [ [ 0 ], [ 1 ] ],
> [ [ 1, 2 ], [ 2, 2 ] ], [ 1 ], [ 1 ]), [ 1 ]);;
gap> P2:=Predicaton(Automaton("det", 4, [ [ 0 ], [ 1 ] ],
> [ [ 3, 2, 2, 4 ], [ 2, 2, 4, 2 ] ], [ 1 ], [ 4 ]), [ 1 ]);;
gap> P3:=UnionAut(P1, P2);;
gap> Display(P3);
Predicaton: nondeterministic finite automaton on 2 letters with 6 states, 
the variable position list [ 1 ] and the following transitions:
         |  1      2      3      4      5      6      
------------------------------------------------------
  [ 0 ]  |  [ 1 ]  [ 2 ]  [ 5 ]  [ 4 ]  [ 4 ]  [ 6 ]  
  [ 1 ]  |  [ 2 ]  [ 2 ]  [ 4 ]  [ 4 ]  [ 6 ]  [ 4 ]  
 Initial states: [ 1, 3 ]
 Final states:   [ 1, 6 ]
gap> M:=MinimalAut(P3);;
gap> Display(M);
Predicaton: deterministic finite automaton on 2 letters with 4 states, 
the variable position list [ 1 ] and the following transitions:
         |  1  2  3  4  
------------------------
  [ 0 ]  |  1  2  2  3  
  [ 1 ]  |  1  1  2  1  
 Initial states: [ 4 ]
 Final states:   [ 2, 3, 4 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="IsRecognizedByAut" Arg="P, word"/>
<Description>
The function <C>IsRecognizedByAut</C> checks if a <A>word</A>, given by its letters, is accepted by the <C>Automaton</C> or <C>Predicaton</C> <A>P</A>.
<Example><![CDATA[
gap> P:=Predicaton(Automaton("det", 5, [ [ 0 ], [ 1 ] ],
> [ [ 5, 5, 5, 4, 5 ], [ 2, 3, 4, 5, 5 ] ], [ 1 ], [ 4 ]), [ 1 ]);;
gap> Display(P);
Predicaton: deterministic finite automaton on 2 letters with 5 states, 
the variable position list [ 1 ] and the following transitions:
         |  1  2  3  4  5  
---------------------------
  [ 0 ]  |  5  5  5  4  5  
  [ 1 ]  |  2  3  4  5  5  
 Initial states: [ 1 ]
 Final states:   [ 4 ]
gap> IsRecognizedByAut(P,[[1],[1],[1]]);
true
gap> IsRecognizedByAut(P,[[1],[1],[1],[0],[0]]);
true
gap> IsRecognizedByAut(P,[[1],[1],[0]]);
false
]]></Example>
</Description>
</ManSection>

</Section>

<Section Label="Functions On Predicata"><Heading>Basic functions on Predicata</Heading>
The following functions act only on Predicata, accessing and modifying the alphabet <M>A:=\{0,1\}^n</M> for a natural number <Math>n</Math> (including 0).

<ManSection>
<Func Name="DecToBin" Arg="D"/>
<Description>
The function <C>DecToBin</C> returns for a natural numbers <A>D</A> or the list of its binary representation. Note that here, motivated on how the automata read the words, the binary representation are read in the other direction than usual, for example <M>4 = &leftsquare;0,0,1&rightsquare;_2</M>.
<Example><![CDATA[
gap> DecToBin(4);
[ 0, 0, 1 ]
gap> DecToBin(0);
[ 0 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="BinToDec" Arg="B"/>
<Description>
The function <C>BinToDec</C> returns for a list <A>B</A> (i.e. a binary representation), containing <C>0</C>s and <C>1</C>s, the corresponding natural number. Note again that here the <M>\sum b_{i+1}*2^i</M> starting at <M>i=0</M> is evaluated the other way around than it's usually done.
<Example><![CDATA[
gap> BinToDec([ 0, 0, 1 ]);
4
gap> BinToDec([ 0, 0, 1, 0, 0, 0, 0 ]);
4
gap> BinToDec([ ]);
0

]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="IsAcceptedWordByPredicaton" Arg="P, L"/>
<Func Name="IsAcceptedByPredicaton" Arg="P, L"/>
<Description>
The function <C>IsAcceptedWordByPredicaton</C> checks if a list of natural numbers <A>L</A> or a list of binary representation <A>L</A> is accepted by the <C>Predicaton</C> <A>P</A>. Compare with <Ref Func="IsRecognizedByAut"/>, which uses the letters instead of the words.
<Example><![CDATA[
gap> P:=Predicaton(Automaton("det", 5, [ [ 0, 0 ], [ 1, 0 ], [ 0, 1 ], [ 1, 1 ] ],
> [ [ 2, 2, 2, 2, 5 ], [ 4, 2, 2, 3, 2 ], [ 2, 2, 2, 2, 2 ], [ 2, 2, 5, 2, 2 ] ],
> [ 1 ], [ 5 ]), [ 1, 2 ]);;
gap> Display(P);
Predicaton: deterministic finite automaton on 4 letters with 5 states, 
the variable position list [ 1, 2 ] and the following transitions:
            |  1  2  3  4  5  
------------------------------
  [ 0, 0 ]  |  2  2  2  2  5  
  [ 1, 0 ]  |  4  2  2  3  2  
  [ 0, 1 ]  |  2  2  2  2  2  
  [ 1, 1 ]  |  2  2  5  2  2  
 Initial states: [ 1 ]
 Final states:   [ 5 ]
gap> IsAcceptedWordByPredicaton(P, [ 7, 4 ]);
true
gap> IsAcceptedWordByPredicaton(P, [ DecToBin(7), DecToBin(4) ]);
true
gap> IsAcceptedWordByPredicaton(P, [ [ 1, 1, 1, 0 ], [ 0, 0, 1, 0, 0, 0 ] ]);
true
gap> IsRecognizedByAut(P, [ [ 1, 0 ], [ 1, 0 ], [ 1, 1 ] ]); # 1st row = 7, 2nd row = 4
true
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="AcceptedWordsByPredicaton" Arg="P[, b]"/>
<Func Name="AcceptedByPredicaton" Arg="P[, b]"/>
<Description>
The function <C>AcceptedWordsByPredicaton</C> returns the accepted words of the <C>Predicaton</C> <A>P</A> up to an upper bound <A>b</A> (on default <C>b=10</C>), either a positive integer or a list with positive integers as an individual bound for each variable. Alternatively, list of lists where each list contains the to be tested values is also allowed. 
<Example><![CDATA[
gap> P:=Predicaton(Automaton("det", 5, [ [ 0, 0 ], [ 1, 0 ], [ 0, 1 ], [ 1, 1 ] ],
> [ [ 2, 2, 2, 2, 5 ], [ 4, 2, 2, 3, 2 ], [ 2, 2, 2, 2, 2 ], [ 2, 2, 5, 2, 2 ] ],
> [ 1 ], [ 5 ]), [ 1, 2 ]);;
gap> AcceptedWordsByPredicaton(P, [ 10, 20 ]);
[ [ 7, 4 ] ]
gap> P:=Predicaton(Automaton("det", 3, [ [ 0 ], [ 1 ] ], 
> [ [ 1, 3, 2 ], [ 2, 1, 3 ] ], [ 1 ], [ 1 ]), [ 1 ]);;
gap> Display(P);
Predicaton: deterministic finite automaton on 2 letters with 3 states, 
the variable position list [ 1 ] and the following transitions:
         |  1  2  3  
---------------------
  [ 0 ]  |  1  3  2  
  [ 1 ]  |  2  1  3  
 Initial states: [ 1 ]
 Final states:   [ 1 ]
gap> AcceptedWordsByPredicaton(P, 29);
[ [ 0 ], [ 3 ], [ 6 ], [ 9 ], [ 12 ], [ 15 ], [ 18 ], [ 21 ], [ 24 ], [ 27 ] ]
gap> AcceptedWordsByPredicaton(P, [ [121..144] ]);
[ [ 123 ], [ 126 ], [ 129 ], [ 132 ], [ 135 ], [ 138 ], [ 141 ], [ 144 ] ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="DisplayAcceptedWordsByPredicaton" Arg="P[, b, t]"/>
<Func Name="DisplayAcceptedByPredicaton" Arg="P[, b, t]"/>
<Description>
The function <C>DisplayAcceptedWordsByPredicaton</C> prints the accepted words of the <C>Predicaton</C> <A>P</A> in a nice way. For one variable as a "list" with <C>YES/no</C>, for two variables as a "matrix" containing <C>YES/no</C> and for three variables as a "matrix", which entries are the third accepted natural numbers. The optional parameter <A>b</A> gives an upper bound for the displayed natural numbers, where either a positive integer or a list of positive integers denotes the maximal natural numbers which are asked for. The second optional parameter, if <C>true</C> allows to reduce <C>YES/no</C> to <C>Y/n</C> for the case of one variable.
<Example><![CDATA[
gap> P:=Predicaton(Automaton("det", 5, [ [ 0, 0 ], [ 1, 0 ], [ 0, 1 ], [ 1, 1 ] ], 
> [ [ 2, 2, 2, 3, 5 ], [ 4, 2, 2, 3, 2 ], [ 2, 2, 2, 3, 2 ], [ 2, 2, 5, 3, 2 ] ],
> [ 1 ], [ 5 ]), [ 1, 2 ]);;
gap> AcceptedWordsByPredicaton(P);
[ [ 5, 4 ], [ 5, 6 ], [ 7, 4 ], [ 7, 6 ] ]  
gap> DisplayAcceptedWordsByPredicaton(P, [8,10]);
 If the following words are accepted by the given automaton, then: YES,
 otherwise if not accepted: no.

     | 0   1   2   3   4   5   6   7   8   9   10  
 -------------------------------------------------
   0 | no  no  no  no  no  no  no  no  no  no  no  
   1 | no  no  no  no  no  no  no  no  no  no  no  
   2 | no  no  no  no  no  no  no  no  no  no  no  
   3 | no  no  no  no  no  no  no  no  no  no  no  
   4 | no  no  no  no  no  no  no  no  no  no  no  
   5 | no  no  no  no  YES no  YES no  no  no  no  
   6 | no  no  no  no  no  no  no  no  no  no  no  
   7 | no  no  no  no  YES no  YES no  no  no  no  
   8 | no  no  no  no  no  no  no  no  no  no  no
   
gap> P:=Predicaton(Automaton("det", 5, [ [ 0 ], [ 1 ] ], 
> [ [ 3, 2, 5, 4, 4 ], [ 3, 2, 4, 2, 4 ] ], 
> [ 1 ], [ 3, 4, 5, 1 ]), [ 1 ]);;
gap> Display(P);
Predicaton: deterministic finite automaton on 2 letters with 5 states, 
the variable position list [ 1 ] and the following transitions:
         |  1  2  3  4  5  
---------------------------
  [ 0 ]  |  3  2  5  4  4  
  [ 1 ]  |  3  2  4  2  4  
 Initial states: [ 1 ]
 Final states:   [ 1, 3, 4, 5 ]
gap> AcceptedWordsByPredicaton(P, 19);
[ [ 0 ], [ 1 ], [ 2 ], [ 3 ], [ 4 ], [ 5 ] ]
gap> DisplayAcceptedWordsByPredicaton(P, 29, true);
 If the following words are accepted by the given automaton, then: Y,
 otherwise if not accepted: n.
   0: Y   1: Y   2: Y   3: Y   4: Y   5: Y   6: n   7: n   8: n   9: n
  10: n  11: n  12: n  13: n  14: n  15: n  16: n  17: n  18: n  19: n
  20: n  21: n  22: n  23: n  24: n  25: n  26: n  27: n  28: n  29: n

]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="DisplayAcceptedWordsByPredicatonInNxN" Arg="P[, b]"/>
<Func Name="DisplayAcceptedByPredicatonInNxN" Arg="P[, b]"/>
<Description>
The function <C>DisplayAcceptedWordsByPredicatonInNxN</C> prints the accepted words of the <C>Predicaton</C> <A>P</A> with a variable position list of length two in a fancy way in <M>&NN; \times &NN;</M>. It "draws" the natural number solutions of linear equations, which can be seen, due to the linearity, as "lines". The optional parameter <A>l</A> gives an upper bound for the displayed accepted words, it must be a list containing two positive integers. 
<Example><![CDATA[
gap> P:=Predicaton(Automaton("det", 14, [ [ 0, 0 ], [ 1, 0 ], [ 0, 1 ], [ 1, 1 ] ],
> [ [ 6, 2, 2, 3, 4, 2, 2, 3, 7, 2, 10, 12, 12, 14 ], 
> [ 2, 2, 12, 2, 9, 11, 7, 7, 2, 13, 2, 2, 7, 2 ], 
> [ 2, 2, 12, 2, 7, 8, 14, 14, 2, 14, 2, 2, 14, 2 ], 
> [ 5, 2, 2, 12, 3, 2, 2, 12, 7, 2, 13, 2, 2, 14 ] ], 
> [ 1 ], [ 12, 13, 14 ]), [ 1, 2 ]);;
gap> Display(P);
Predicaton: deterministic finite automaton on 4 letters with 14 states, 
the variable position list [ 1, 2 ] and the following transitions:
            |  1  2  3  4  5  6  7  8  9  10 11 12 13 14 
---------------------------------------------------------
  [ 0, 0 ]  |  6  2  2  3  4  2  2  3  7  2  10 12 12 14 
  [ 1, 0 ]  |  2  2  12 2  9  11 7  7  2  13 2  2  7  2  
  [ 0, 1 ]  |  2  2  12 2  7  8  14 14 2  14 2  2  14 2  
  [ 1, 1 ]  |  5  2  2  12 3  2  2  12 7  2  13 2  2  14 
 Initial states: [ 1 ]
 Final states:   [ 12, 13, 14 ]
gap> DisplayAcceptedWordsByPredicatonInNxN(P, [ 15, 15 ]);
  15 -                                      o                         
     |
  14 -                                  o                             
     |
  13 -                              o                                 
     |
  12 -                          o                                     
     |
  11 -                      o                                         
     |
  10 -  o               o                                             
     |
   9 -      o       o                                                 
     |
   8 -          o                                                     
     |
   7 -      o       o                                                 
     |
   6 -  o               o                                             
     |
   5 -                      o                                         
     |
   4 -                          o                                     
     |
   3 -                              o                                 
     |
   2 -                                  o                             
     |
   1 -                                      o                         
     |
   0 -                                          o                     
     |
   --+--|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---->
     |  0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15 
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="AutomatonOfPredicaton" Arg="P"/>
<Func Name="AutOfPredicaton" Arg="P"/>
<Description>
The function <C>AutomatonOfPredicaton</C> returns the <C>Automaton</C> of a <C>Predicaton</C> <A>P</A>.
<Example><![CDATA[
gap> P:=Predicaton(Automaton("det", 4, [ [ 0 ], [ 1 ] ], 
> [ [ 4, 2, 3, 3 ], [ 3, 2, 2, 3 ] ], [ 1 ], [ 3, 4, 1 ]), [ 1 ]);
< Predicaton: deterministic finite automaton on 2 letters with 4 states 
and the variable position list [ 1 ]. >
gap> AutomatonOfPredicaton(P);
< deterministic automaton on 2 letters with 4 states >
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="VariablePositionListOfPredicaton" Arg="P"/>
<Func Name="VarPosListOfPredicaton" Arg="P"/>
<Description>
The function <C>VariablePositionListOfPredicaton</C> returns the variable position list of a <C>Predicaton</C> <A>P</A>.
<Example><![CDATA[
gap> P:=Predicaton(Automaton("det", 5, [ [ 0, 0 ], [ 1, 0 ], [ 0, 1 ], [ 1, 1 ] ],
> [ [ 1, 2, 2, 3, 2 ], [ 4, 2, 2, 5, 2 ], [ 2, 2, 1, 2, 3 ], [ 2, 2, 4, 2, 5 ] ],
> [ 1 ], [ 1 ]), [ 4, 9 ]);;
gap> VariablePositionListOfPredicaton(P);
[ 4, 9 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="SetVariablePositionListOfPredicaton" Arg="P, l"/>
<Func Name="SetVarPosListOfPredicaton" Arg="P, l"/>
<Description>
The function <C>SetVariablePositionListOfPredicaton</C> sets the variable position list of a <C>Predicaton</C> <A>P</A>, permuting the alphabet if necessary, see <Ref Func="PermutedAlphabetPredicaton"/>.
<Example><![CDATA[
gap> P:=Predicaton(Automaton("det", 5, [ [ 0, 0 ], [ 1, 0 ], [ 0, 1 ], [ 1, 1 ] ],
> [ [ 1, 2, 2, 3, 2 ], [ 4, 2, 2, 5, 2 ], [ 2, 2, 1, 2, 3 ], [ 2, 2, 4, 2, 5 ] ],
> [ 1 ], [ 1 ]), [ 4, 9 ]);;
gap> SetVariablePositionListOfPredicaton(P, [ 1, 2 ]);
gap> VariablePositionListOfPredicaton(P);
[ 1, 2 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="ProductLZeroPredicaton" Arg="P"/>
<Description>
The function <C>ProductLZeroPredicaton</C> takes the <C>Predicaton</C> <A>P</A> and adds a new state. This new state is final and is reached through <C>[0,...,0]</C> from all <C>Final</C> states. Hence the returned <C>Predicaton</C> recognizes the product of the languages of the given <C>Predicaton</C> and the language containing all the zero words.
<Example><![CDATA[
gap> P:=Predicaton(Automaton("det", 5, [ [ 0 ], [ 1 ] ], [ [ 3, 2, 4, 2, 2 ],
> [ 2, 2, 2, 5, 2 ] ], [ 1 ], [ 5 ]), [ 1 ]);;
gap> Display(P);
Predicaton: deterministic finite automaton on 2 letters with 5 states, 
the variable position list [ 1 ] and the following transitions:
         |  1  2  3  4  5  
---------------------------
  [ 0 ]  |  3  2  4  2  2  
  [ 1 ]  |  2  2  2  5  2  
 Initial states: [ 1 ]
 Final states:   [ 5 ]
gap> IsAcceptedWordByPredicaton(P, [ [ 0, 0, 1 ] ]);
true
gap> IsAcceptedWordByPredicaton(P, [ [ 0, 0, 1, 0 ] ]);
false
gap> PredicatonToRatExp(P);
[ 0 ][ 0 ][ 1 ]
gap> Q:=ProductLZeroPredicaton(P);;
gap> Display(Q);
Predicaton: nondeterministic finite automaton on 2 letters with 6 states, 
the variable position list [ 1 ] and the following transitions:
         |  1         2         3         4         5         6         
------------------------------------------------------------------------
  [ 0 ]  |  [ 3 ]     [ 2 ]     [ 4 ]     [ 2 ]     [ 2, 6 ]  [ 6 ]     
  [ 1 ]  |  [ 2 ]     [ 2 ]     [ 2 ]     [ 5 ]     [ 2 ]     [ ]       
 Initial states: [ 1 ]
 Final states:   [ 5, 6 ]
gap> IsAcceptedWordByPredicaton(Q, [ [ 0, 0, 1 ] ]);
true
gap> IsAcceptedWordByPredicaton(Q, [ [ 0, 0, 1, 0 ] ]);
true
gap> PredicatonToRatExp(Q);
[ 0 ][ 0 ][ 1 ]([ 0 ][ 0 ]*U@)
gap> M:=MinimalAut(Q);;
gap> M:=PermutedStatesAut(M, [ 5, 2, 4, 3, 1 ]);;
gap> Display(M);
Predicaton: deterministic finite automaton on 2 letters with 5 states, 
the variable position list [ 1 ] and the following transitions:
         |  1  2  3  4  5  
---------------------------
  [ 0 ]  |  3  2  4  2  5  
  [ 1 ]  |  2  2  2  5  2  
 Initial states: [ 1 ]
 Final states:   [ 5 ]
gap> PredicatonToRatExp(M);
[ 0 ][ 0 ][ 1 ][ 0 ]*
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="RightQuotientLZeroPredicaton" Arg="P"/>
<Description>
The function <C>RightQuotientLZeroPredicaton</C> takes the <C>Predicaton</C> <A>P</A> and runs through all final states. If a <C>Final</C> state is reached with <C>[0,...,0]</C> then this state is added to the final states. Hence the returned <C>Predicaton</C> recognizes the right quotient of the language of the given <C>Predicaton</C> with the language containing only the zero words.
<Example><![CDATA[
gap> P:=Predicaton(Automaton("det", 6, [ [ 0 ], [ 1 ] ], [ [ 3, 2, 4, 2, 6, 2 ],
> [ 2, 2, 2, 5, 2, 2 ] ], [ 1 ], [ 6 ]), [ 1 ]);;
gap> Display(P);
gap> Display(P);
Predicaton: deterministic finite automaton on 2 letters with 6 states, 
the variable position list [ 1 ] and the following transitions:
         |  1  2  3  4  5  6  
------------------------------
  [ 0 ]  |  3  2  4  2  6  2  
  [ 1 ]  |  2  2  2  5  2  2  
 Initial states: [ 1 ]
 Final states:   [ 6 ]
gap> IsAcceptedWordByPredicaton(P, [ 4 ]);
false
gap> IsAcceptedWordByPredicaton(P, [ [ 0, 0, 1 ] ]);
false
gap> IsAcceptedWordByPredicaton(P, [ [ 0, 0, 1, 0 ] ]);
true
gap> PredicatonToRatExp(P);
[ 0 ][ 0 ][ 1 ][ 0 ]
gap> Q:=RightQuotientLZeroPredicaton(P);;
gap> Display(Q);
Predicaton: nondeterministic finite automaton on 2 letters with 6 states, 
the variable position list [ 1 ] and the following transitions:
         |  1      2      3      4      5      6      
------------------------------------------------------
  [ 0 ]  |  [ 3 ]  [ 2 ]  [ 4 ]  [ 2 ]  [ 6 ]  [ 2 ]  
  [ 1 ]  |  [ 2 ]  [ 2 ]  [ 2 ]  [ 5 ]  [ 2 ]  [ 2 ]  
 Initial states: [ 1 ]
 Final states:   [ 5, 6 ]
gap> IsAcceptedWordByPredicaton(Q, [ 4 ]);
true
gap> IsAcceptedWordByPredicaton(Q, [ [ 0, 0, 1 ] ]);
true
gap> IsAcceptedWordByPredicaton(Q, [ [ 0, 0, 1, 0 ] ]);
true
gap> PredicatonToRatExp(Q);
[ 0 ][ 0 ][ 1 ]([ 0 ]U@)
gap> M:=MinimalAut(Q);;
gap> M:=PermutedStatesAut(M, [ 6, 2, 5, 4, 3, 1 ]);;
gap> Display(M);
Predicaton: deterministic finite automaton on 2 letters with 6 states, 
the variable position list [ 1 ] and the following transitions:
         |  1  2  3  4  5  6  
------------------------------
  [ 0 ]  |  3  2  4  2  6  2  
  [ 1 ]  |  2  2  2  5  2  2  
 Initial states: [ 1 ]
 Final states:   [ 5, 6 ]
gap> IsAcceptedWordByPredicaton(M, [ 4 ]);
true
gap> PredicatonToRatExp(M);
[ 0 ][ 0 ][ 1 ]([ 0 ]U@)
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="NormalizedLeadingZeroPredicaton" Arg="P"/>
<Description>
The function <C>NormalizedLeadingZeroPredicaton</C> returns the union of <Ref Func="ProductLZeroPredicaton"/> and <Ref Func="RightQuotientLZeroPredicaton"/> of the given <C>Predicaton</C> <A>P</A>. Therefore the returned <C>Predicaton</C> accepts any previously accepted words with cancelled or added leading zeros.
<Example><![CDATA[
gap> P:=Predicaton(Automaton("det", 7, [ [ 0 ], [ 1 ] ], [ [ 3, 2, 4, 2, 6, 2, 2], 
> [ 2, 2, 7, 5, 2, 2, 2 ] ], [ 1 ], [ 6, 7 ]), [ 1 ]);;
gap> Display(P);
Predicaton: deterministic finite automaton on 2 letters with 7 states, 
the variable position list [ 1 ] and the following transitions:
         |  1  2  3  4  5  6  7  
---------------------------------
  [ 0 ]  |  3  2  4  2  6  2  2  
  [ 1 ]  |  2  2  7  5  2  2  2  
 Initial states: [ 1 ]
 Final states:   [ 6, 7 ]
gap> IsAcceptedWordByPredicaton(P, [ [ 0, 1 ] ]);
true
gap> IsAcceptedWordByPredicaton(P, [ [ 0, 1, 0 ] ]);
false
gap> IsAcceptedWordByPredicaton(P, [ [ 0, 0, 1 ] ]);
false
gap> IsAcceptedWordByPredicaton(P, [ [ 0, 0, 1, 0 ] ]);
true
gap> PredicatonToRatExp(P);
[ 0 ]([ 1 ]U[ 0 ][ 1 ][ 0 ])
gap> Q:=NormalizedLeadingZeroPredicaton(P);;
gap> Display(Q);
Predicaton: nondeterministic finite automaton on 2 letters with 16 states,
the variable position list [ 1 ] and the following transitions:
         |  1       2       3       4       5       6       7       8       
----------------------------------------------------------------------------
  [ 0 ]  |  [ 2 ]   [ 4 ]   [ 3 ]   [ 3 ]   [ 7 ]   [ 8 ]   [ 9 ]   [ 7 ]   
  [ 1 ]  |  [ 3 ]   [ 5 ]   [ 3 ]   [ 6 ]   [ 3 ]   [ 3 ]   [ 3 ]   [ 3 ]   
 ...
         |  9       10      11      12      13      14      15      16      
----------------------------------------------------------------------------
  [ 0 ]  |  [ 9 ]   [ 11 ]  [ 13 ]  [ 12 ]  [ 12 ]  [ 12 ]  [ 16 ]  [ 12 ]  
  [ 1 ]  |  [ 3 ]   [ 12 ]  [ 14 ]  [ 12 ]  [ 15 ]  [ 12 ]  [ 12 ]  [ 12 ]  
 Initial states: [ 1, 10 ]
 Final states:   [ 5, 7, 8, 9, 14, 15, 16 ]
gap> AcceptedWordsByPredicaton(Q, 10);
[ [ 2 ], [ 4 ] ]
gap> IsAcceptedWordByPredicaton(Q, [ [ 0, 1 ] ]);
true
gap> IsAcceptedWordByPredicaton(Q, [ [ 0, 1, 0 ] ]);
true
gap> IsAcceptedWordByPredicaton(Q, [ [ 0, 0, 1 ] ]);
true
gap> IsAcceptedWordByPredicaton(Q, [ [ 0, 0, 1, 0 ] ]);
true
gap> M:=MinimalAut(Q);;
gap> M:=PermutedStatesAut(M, [ 3, 5, 1, 4, 2 ]);;
gap> Display(M);
Predicaton: deterministic finite automaton on 2 letters with 5 states,
the variable position list [ 1 ] and the following transitions:
         |  1  2  3  4  5  
---------------------------
  [ 0 ]  |  3  2  4  2  5  
  [ 1 ]  |  2  2  5  5  2  
 Initial states: [ 1 ]
 Final states:   [ 5 ]
gap> AcceptedWordsByPredicaton(M, 10);
[ [ 2 ], [ 4 ] ]
gap> PredicatonToRatExp(M);
[ 0 ]([ 0 ][ 1 ]U[ 1 ])[ 0 ]*
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="SortedAlphabetPredicaton" Arg="P"/>
<Func Name="SortedAbcPredicaton" Arg="P"/>
<Description>
The function <C>SortedAlphabetPredicaton</C> returns the <C>Predicaton</C> <A>P</A> with the component-wise sorted <C>Alphabet</C> (from right to left with <M>0&lt;1</M>).
<Example><![CDATA[
gap> P:=Predicaton(Automaton("det", 3, [ [ 0, 0, 0 ], [ 0, 0, 1 ], [ 1, 0, 0 ],
> [ 1, 0, 1 ], [ 0, 1, 0 ], [ 0, 1, 1 ], [ 1, 1, 0 ], [ 1, 1, 1 ] ],
> [ [ 1, 3, 3 ], [ 3, 2, 3 ], [ 3, 2, 3 ], [ 2, 3, 3 ], [ 3, 1, 3 ], 
> [ 1, 3, 3 ], [ 1, 3, 3 ], [ 3, 2, 3 ] ], [ 1 ], [ 1 ]), [ 1, 2, 3 ]);;
gap> Display(P);
Predicaton: deterministic finite automaton on 8 letters with 3 states, 
the variable position list [ 1, 2, 3 ] and the following transitions:
               |  1  2  3  
 ---------------------------
  [ 0, 0, 0 ]  |  1  3  3  
  [ 0, 0, 1 ]  |  3  2  3  
  [ 1, 0, 0 ]  |  3  2  3  
  [ 1, 0, 1 ]  |  2  3  3  
  [ 0, 1, 0 ]  |  3  1  3  
  [ 0, 1, 1 ]  |  1  3  3  
  [ 1, 1, 0 ]  |  1  3  3  
  [ 1, 1, 1 ]  |  3  2  3  
 Initial states: [ 1 ]
 Final states:   [ 1 ]
gap> Q:=SortedAlphabetPredicaton(P);;
gap> Display(Q);
Predicaton: deterministic finite automaton on 8 letters with 3 states,
the variable position list [ 1, 2, 3 ] and the following transitions:
               |  1  2  3  
 ---------------------------
  [ 0, 0, 0 ]  |  1  3  3  
  [ 1, 0, 0 ]  |  3  2  3  
  [ 0, 1, 0 ]  |  3  1  3  
  [ 1, 1, 0 ]  |  1  3  3  
  [ 0, 0, 1 ]  |  3  2  3  
  [ 1, 0, 1 ]  |  2  3  3  
  [ 0, 1, 1 ]  |  1  3  3  
  [ 1, 1, 1 ]  |  3  2  3  
 Initial states: [ 1 ]
 Final states:   [ 1 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="FormattedPredicaton" Arg="P"/>
<Description>
The function <C></C> computes first the <Ref Func="NormalizedLeadingZeroPredicaton"/> and then the <Ref Func="MinimalAut"/> of the <C>Predicaton</C> <A>P</A>.
<Example><![CDATA[
gap> P:=Predicaton(Automaton("det", 7, [ [ 0 ], [ 1 ] ], [ [ 3, 2, 4, 2, 6, 2, 2], 
> [ 2, 2, 7, 5, 2, 2, 2 ] ], [ 1 ], [ 6, 7 ]), [ 1 ]);;
gap> Display(P);
Predicaton: deterministic finite automaton on 2 letters with 7 states, 
the variable position list [ 1 ] and the following transitions:
         |  1  2  3  4  5  6  7  
---------------------------------
  [ 0 ]  |  3  2  4  2  6  2  2  
  [ 1 ]  |  2  2  7  5  2  2  2  
 Initial states: [ 1 ]
 Final states:   [ 6, 7 ]
gap> PredicatonToRatExp(P);
[ 0 ]([ 1 ]U[ 0 ][ 1 ][ 0 ])
gap> M:=FormattedPredicaton(P);;
gap> Display(M);
Predicaton: deterministic finite automaton on 2 letters with 5 states, 
the variable position list [ 1 ] and the following transitions:
         |  1  2  3  4  5  
---------------------------
  [ 0 ]  |  4  2  1  5  5  
  [ 1 ]  |  2  5  5  2  5  
 Initial states: [ 3 ]
 Final states:   [ 2 ]
gap> PredicatonToRatExp(M);
[ 0 ]([ 0 ][ 1 ]U[ 1 ])[ 0 ]*
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="IsValidInput" Arg="P, n"/>
<Description>
The function <C>IsValidInput</C> checks if the list <A>n</A> contains positive integers and if it is a valid variable position list of the given <C>Predicaton</C> <A>P</A>, i.e. variable position list is a subset of <A>n</A>.
<Example><![CDATA[
gap> P:=Predicaton(Automaton("det", 2, [ [ 0, 0 ], [ 1, 0 ], [ 0, 1 ], [ 1, 1 ] ], 
> [ [ 1, 2 ], [ 2, 2 ], [ 1, 2 ], [ 2, 2 ] ], [ 1 ], [ 1 ]), [ 2, 4 ]);;
gap> IsValidInput(P, [ 1, 2, 3 ]);
The new variable position list must contain the old one of the Predicaton. 
Compare [ 2, 4 ] with [ 1, 2, 3 ].
false
gap> IsValidInput(P, [ 1, 2, 3, 4 ]);
true
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="ExpandedPredicaton" Arg="P, n"/>
<Description>
The function <C>ExpandedPredicaton</C> returns the <C>Predicaton</C> <A>P</A> with the new variable position list <A>n</A>. For each new variable position in <A>n</A>, the alphabet size doubles. In each step 0s and 1s are added at the correct position in all letters of the alphabet, whereas the transition matrix rows are copied accordingly. Formally this corresponds to the preimage of the homomorphism ignoring a component of the letters applied to the deterministic finite automaton.
<Example><![CDATA[
gap> P:=Predicaton(Automaton("det", 3, [ [ 0 ], [ 1 ] ], [ [ 2, 2, 3 ], 
> [ 3, 2, 2 ] ], [ 1 ], [ 3 ]), [ 1 ]);
gap> Display(P);
Predicaton: deterministic finite automaton on 2 letters with 3 states, 
the variable position list [ 1 ] and the following transitions:
         |  1  2  3  
---------------------
  [ 0 ]  |  2  2  3  
  [ 1 ]  |  3  2  2  
 Initial states: [ 1 ]
 Final states:   [ 3 ]
gap> Q:=ExpandedPredicaton(P, [ 1, 2, 3 ]);;
gap> Display(Q);
Predicaton: deterministic finite automaton on 8 letters with 3 states, 
the variable position list [ 1, 2, 3 ] and the following transitions:
               |  1  2  3  
---------------------------
  [ 0, 0, 0 ]  |  2  2  3  
  [ 1, 0, 0 ]  |  3  2  2  
  [ 0, 1, 0 ]  |  2  2  3  
  [ 1, 1, 0 ]  |  3  2  2  
  [ 0, 0, 1 ]  |  2  2  3  
  [ 1, 0, 1 ]  |  3  2  2  
  [ 0, 1, 1 ]  |  2  2  3  
  [ 1, 1, 1 ]  |  3  2  2  
 Initial states: [ 1 ]
 Final states:   [ 3 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="ProjectedPredicaton" Arg="P, p"/>
<Description>
The function <C>ProjectedPredicaton</C> returns the <C>Predicaton</C> <A>P</A> with the new variable position list without <A>p</A>. The alphabet is halved, ignoring the 0s and 1s entries at position <A>p</A> relative to the <C>VariablePositionList</C>, whereas the transition matrix rows are combined accordingly. Formally this corresponds to the image of homomorphism which ignores the <A>p</A>-th component of the letters applied to the deterministic finite automaton. This function is used for the interpretation of the existence quantifier.
<Example><![CDATA[
gap> P:=Predicaton(Automaton("det", 3, [ [ 0, 0 ], [ 1, 0 ], [ 0, 1 ], [ 1, 1 ] ],
> [ [ 1, 3, 3 ], [ 2, 3, 3 ], [ 3, 1, 3 ], [ 3, 2, 3 ] ], [ 1 ], [ 1 ]),
> [ 1, 2 ]);;
gap> Display(P);
Predicaton: deterministic finite automaton on 4 letters with 3 states, 
the variable position list [ 1, 2 ] and the following transitions:
            |  1  2  3  
------------------------
  [ 0, 0 ]  |  1  3  3  
  [ 1, 0 ]  |  2  3  3  
  [ 0, 1 ]  |  3  1  3  
  [ 1, 1 ]  |  3  2  3  
 Initial states: [ 1 ]
 Final states:   [ 1 ]
gap> Q:=ProjectedPredicaton(P, 1);;
gap> Display(Q);
Predicaton: deterministic finite automaton on 2 letters with 3 states, 
the variable position list [ 2 ] and the following transitions:
         |  1  2  3  
---------------------
  [ 0 ]  |  1  2  2  
  [ 1 ]  |  1  2  1  
 Initial states: [ 3 ]
 Final states:   [ 2, 3 ]
gap> AcceptedWordsByPredicaton(P, 10);
[ [ 0, 0 ], [ 1, 2 ], [ 2, 4 ], [ 3, 6 ], [ 4, 8 ], [ 5, 10 ] ]
gap> AcceptedWordsByPredicaton(Q, 10);
[ [ 0 ], [ 2 ], [ 4 ], [ 6 ], [ 8 ], [ 10 ] ]
gap> PredicatonToRatExp(P);
([ 1, 0 ][ 1, 1 ]*[ 0, 1 ]U[ 0, 0 ])*
gap> PredicatonToRatExp(Q);
[ 0 ]([ 0 ]U[ 1 ])*U@
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="NegatedProjectedNegatedPredicaton" Arg="P, p"/>
<Description>
The function <C>NegatedProjectedNegatedPredicaton</C> returns the negated (<Ref Func="NegatedAut"/>), projected (<Ref Func="ProjectedPredicaton"/> with <A>p</A>) and negated <C>Predicaton</C> <A>P</A>. This function is used for the interpretation of the for all quantifier.
<Example><![CDATA[
gap> P:=Predicaton(Automaton("det", 2, [ [ 0, 0 ], [ 1, 0 ], [ 0, 1 ], [ 1, 1 ] ], 
> [ [ 1, 2 ], [ 2, 2 ], [ 2, 2 ], [ 1, 2 ] ], [ 1 ], [ 1 ]), [ 1, 2 ]);;
gap> Display(P);
Predicaton: deterministic finite automaton on 4 letters with 2 states, 
the variable position list [ 1, 2 ] and the following transitions:
            |  1  2  
---------------------
  [ 0, 0 ]  |  1  2  
  [ 1, 0 ]  |  2  2  
  [ 0, 1 ]  |  2  2  
  [ 1, 1 ]  |  1  2  
 Initial states: [ 1 ]
 Final states:   [ 1 ]
gap> AcceptedWordsByPredicaton(P, 5);
[ [ 0, 0 ], [ 1, 1 ], [ 2, 2 ], [ 3, 3 ], [ 4, 4 ], [ 5, 5 ] ]
gap> Q1:=ProjectedPredicaton(P, 1);;
gap> Display(Q1);
Predicaton: deterministic finite automaton on 2 letters with 1 state, 
the variable position list [ 2 ] and the following transitions:
         |  1  
---------------
  [ 0 ]  |  1  
  [ 1 ]  |  1  
 Initial states: [ 1 ]
 Final states:   [ 1 ]
gap> AcceptedWordsByPredicaton(Q1, 5);
[ [ 0 ], [ 1 ], [ 2 ], [ 3 ], [ 4 ], [ 5 ] ]
gap> Q2:=NegatedProjectedNegatedPredicaton(Q1, 2);;
gap> Display(Q2);
Predicaton: deterministic finite automaton on 1 letter with 1 state, 
the variable position list [ ] and the following transitions:
       |  1  
-------------
  [ ]  |  1  
 Initial states: [ 1 ]
 Final states:   [ 1 ]
gap> AcceptedWordsByPredicaton(Q2);
[ true ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="IntersectionPredicata" Arg="P1, P2, n"/>
<Description>
The function <C>IntersectionPredicata</C> returns the intersection (<Ref Func="IntersectionAut"/>) of the <C>Predicata</C> of <A>P1</A> and <A>P2</A> after resizing (<Ref Func="ExpandedPredicaton"/>) and sorting (<Ref Func="SortedAlphabetPredicaton"/>) the alphabet to match the new variable position list <A>n</A>.
<Example><![CDATA[
gap> P1:=Predicaton(Automaton("det", 5, [ [ 0, 0 ], [ 1, 0 ], [ 0, 1 ], [ 1, 1 ] ],
> [ [ 4, 2, 2, 2, 5 ], [ 2, 2, 5, 2, 2 ], [ 2, 2, 2, 3, 2 ], [ 4, 2, 2, 2, 2 ] ],
> [ 1 ], [ 5 ]), [ 1, 2 ]);;
gap> Display(P1);
Predicaton: deterministic finite automaton on 4 letters with 5 states, 
the variable position list [ 1, 2 ] and the following transitions:
            |  1  2  3  4  5  
------------------------------
  [ 0, 0 ]  |  4  2  2  2  5  
  [ 1, 0 ]  |  2  2  5  2  2  
  [ 0, 1 ]  |  2  2  2  3  2  
  [ 1, 1 ]  |  4  2  2  2  2  
 Initial states: [ 1 ]
 Final states:   [ 5 ]
gap> AcceptedByPredicaton(P1, 10);
[ [ 4, 2 ], [ 5, 3 ] ]
gap> P2:=Predicaton(Automaton("det", 6, [ [ 0, 0 ], [ 1, 0 ], [ 0, 1 ], [ 1, 1 ] ],
> [ [ 5, 2, 2, 3, 2, 6 ], [ 2, 2, 6, 2, 2, 2 ], [ 4, 2, 2, 2, 3, 2 ], 
> [ 2, 2, 2, 2, 2, 2 ] ], [ 1 ], [ 6 ]), [ 1, 2 ]);;
gap> Display(P2);
Predicaton: deterministic finite automaton on 4 letters with 6 states,
the variable position list [ 1, 2 ] and the following transitions:
            |  1  2  3  4  5  6  
---------------------------------
  [ 0, 0 ]  |  5  2  2  3  2  6  
  [ 1, 0 ]  |  2  2  6  2  2  2  
  [ 0, 1 ]  |  4  2  2  2  3  2  
  [ 1, 1 ]  |  2  2  2  2  2  2  
 Initial states: [ 1 ]
 Final states:   [ 6 ]
gap> AcceptedByPredicaton(P2, 10);
[ [ 4, 1 ], [ 4, 2 ] ]
gap> P3:=IntersectionPredicata(P1, P2, [ 1, 2 ]);;
gap> Display(P3);
Predicaton: deterministic finite automaton on 4 letters with 5 states, 
the variable position list [ 1, 2 ] and the following transitions:
            |  1  2  3  4  5  
------------------------------
  [ 0, 0 ]  |  1  2  2  2  4  
  [ 1, 0 ]  |  2  2  1  2  2  
  [ 0, 1 ]  |  2  2  2  3  2  
  [ 1, 1 ]  |  2  2  2  2  2  
 Initial states: [ 5 ]
 Final states:   [ 1 ]
gap> AcceptedByPredicaton(P3, 10);
[ [ 4, 2 ] ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="UnionPredicata" Arg="P"/>
<Description>
The function <C>UnionPredicata</C> returns union (<Ref Func="UnionAut"/>) of the <C>Predicata</C> of <A>P1</A> and <A>P2</A> after resizing (<Ref Func="ExpandedPredicaton"/>) and sorting (<Ref Func="SortedAlphabetPredicaton"/>) the alphabet to match the new variable position list <A>n</A>.
<Example><![CDATA[
gap> P1:=Predicaton(Automaton("det", 5, [ [ 0, 0 ], [ 1, 0 ], [ 0, 1 ], [ 1, 1 ] ],
> [ [ 4, 2, 2, 2, 5 ], [ 2, 2, 5, 2, 2 ], [ 2, 2, 2, 3, 2 ], [ 4, 2, 2, 2, 2 ] ],
> [ 1 ], [ 5 ]), [ 1, 2 ]);;
gap> Display(P1);
Predicaton: deterministic finite automaton on 4 letters with 5 states,
the variable position list [ 1, 2 ] and the following transitions:
            |  1  2  3  4  5  
------------------------------
  [ 0, 0 ]  |  4  2  2  2  5  
  [ 1, 0 ]  |  2  2  5  2  2  
  [ 0, 1 ]  |  2  2  2  3  2  
  [ 1, 1 ]  |  4  2  2  2  2  
 Initial states: [ 1 ]
 Final states:   [ 5 ]
gap> AcceptedByPredicaton(P1, 10);
[ [ 4, 2 ], [ 5, 3 ] ]
gap> P2:=Predicaton(Automaton("det", 6, [ [ 0, 0 ], [ 1, 0 ], [ 0, 1 ], [ 1, 1 ] ],
> [ [ 5, 2, 2, 3, 2, 6 ], [ 2, 2, 6, 2, 2, 2 ], [ 4, 2, 2, 2, 3, 2 ], 
> [ 2, 2, 2, 2, 2, 2 ] ], [ 1 ], [ 6 ]), [ 1, 2 ]);;
gap> Display(P2);
Predicaton: deterministic finite automaton on 4 letters with 6 states, 
the variable position list [ 1, 2 ] and the following transitions:
            |  1  2  3  4  5  6  
---------------------------------
  [ 0, 0 ]  |  5  2  2  3  2  6  
  [ 1, 0 ]  |  2  2  6  2  2  2  
  [ 0, 1 ]  |  4  2  2  2  3  2  
  [ 1, 1 ]  |  2  2  2  2  2  2  
 Initial states: [ 1 ]
 Final states:   [ 6 ]
gap> AcceptedByPredicaton(P2, 10);
[ [ 4, 1 ], [ 4, 2 ] ]
gap> P3:=UnionPredicata(P1, P2, [ 1, 2 ]);;
gap> Display(P3);
Predicaton: deterministic finite automaton on 4 letters with 6 states, 
the variable position list [ 1, 2 ] and the following transitions:
            |  1  2  3  4  5  6  
---------------------------------
  [ 0, 0 ]  |  1  6  6  3  2  6  
  [ 1, 0 ]  |  6  6  1  6  6  6  
  [ 0, 1 ]  |  6  3  6  6  4  6  
  [ 1, 1 ]  |  6  6  6  6  2  6  
 Initial states: [ 5 ]
 Final states:   [ 1 ]
gap> AcceptedWordsByPredicaton(P3, 9);
[ [ 4, 1 ], [ 4, 2 ], [ 5, 3 ] ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="PermutedAlphabetPredicaton" Arg="A, l"/>
<Func Name="PermutedAbcPredicaton" Arg="A, l"/>
<Description>
The function <C>PermutedAlphabetPredicaton</C> returns the <C>Predicaton</C> of the <C>Automaton</C> <A>A</A> with permuted alphabet according to <A>l</A> and accordingly swapped transition matrix rows. This is relevant for the first call of specific automata, where the variable order matters. E.g. the following automaton corresponds to the formula <M>x+y=z</M>, where the the variable <M>x</M> is at position <M>1</M>, <M>y</M> at <M>2</M> and <M>z</M> at <M>3</M>. So creating the the automaton recognizing the same formula but with variable <M>x</M> at position <M>3</M>, <M>y</M> at <M>2</M> and <M>z</M> at <M>1</M> needs the permuted alphabet, i.e. each letter is permuted according to the given variable position list <A>l</A> (here <C>l=[ 3, 2, 1 ]</C>).
<Example><![CDATA[
gap> A:=Automaton("det", 3, [ [ 0, 0, 0 ], [ 0, 0, 1 ], [ 1, 0, 0 ], [ 1, 0, 1 ],
> [ 0, 1, 0 ], [ 0, 1, 1 ], [ 1, 1, 0 ], [ 1, 1, 1 ] ], 
> [ [ 1, 3, 3 ], [ 3, 2, 3 ], [ 3, 2, 3 ], [ 2, 3, 3 ], [ 3, 1, 3 ], [ 1, 3, 3 ],
> [ 1, 3, 3 ], [ 3, 2, 3 ] ], [ 1 ], [ 1 ]);;
gap> DisplayAut(A);
deterministic finite automaton on 8 letters with 3 states 
and the following transitions:
               |  1  2  3  
---------------------------
  [ 0, 0, 0 ]  |  1  3  3  
  [ 0, 0, 1 ]  |  3  2  3  
  [ 1, 0, 0 ]  |  3  2  3  
  [ 1, 0, 1 ]  |  2  3  3  
  [ 0, 1, 0 ]  |  3  1  3  
  [ 0, 1, 1 ]  |  1  3  3  
  [ 1, 1, 0 ]  |  1  3  3  
  [ 1, 1, 1 ]  |  3  2  3  
 Initial states: [ 1 ]
 Final states:   [ 1 ]
gap> P:=PermutedAlphabetPredicaton(A, [3,2,1]);;
gap> Display(P);
Predicaton: deterministic finite automaton on 8 letters with 3 states, 
the variable position list [ 1, 2, 3 ] and the following transitions:
               |  1  2  3  
---------------------------
  [ 0, 0, 0 ]  |  1  3  3  
  [ 1, 0, 0 ]  |  3  2  3  
  [ 0, 0, 1 ]  |  3  2  3  
  [ 1, 0, 1 ]  |  2  3  3  
  [ 0, 1, 0 ]  |  3  1  3  
  [ 1, 1, 0 ]  |  1  3  3  
  [ 0, 1, 1 ]  |  1  3  3  
  [ 1, 1, 1 ]  |  3  2  3  
 Initial states: [ 1 ]
 Final states:   [ 1 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="PredicatonFromAut" Arg="A, l, n"/>
<Description>
The function <C>PredicatonFromAut</C> returns the according to <A>n</A> resized (<Ref Func="ExpandedPredicaton"/>) <C>Predicaton</C> of the <C>Automaton</C> <A>A</A> with the permuted alphabet (<Ref Func="PermutedAlphabetPredicaton"/>), if the <C>VariablePositionList</C> <A>l</A> isn't sorted. 
<Example><![CDATA[
gap> A:=Automaton("det", 3, [ [ 0, 0, 0 ], [ 0, 0, 1 ], [ 1, 0, 0 ], [ 1, 0, 1 ],
> [ 0, 1, 0 ], [ 0, 1, 1 ], [ 1, 1, 0 ], [ 1, 1, 1 ] ], 
> [ [ 1, 3, 3 ], [ 3, 2, 3 ], [ 3, 2, 3 ], [ 2, 3, 3 ], [ 3, 1, 3 ], [ 1, 3, 3 ],
> [ 1, 3, 3 ], [ 3, 2, 3 ] ], [ 1 ], [ 1 ]);;
gap> DisplayAut(A);
deterministic finite automaton on 8 letters with 3 states 
and the following transitions:
               |  1  2  3  
---------------------------
  [ 0, 0, 0 ]  |  1  3  3  
  [ 0, 0, 1 ]  |  3  2  3  
  [ 1, 0, 0 ]  |  3  2  3  
  [ 1, 0, 1 ]  |  2  3  3  
  [ 0, 1, 0 ]  |  3  1  3  
  [ 0, 1, 1 ]  |  1  3  3  
  [ 1, 1, 0 ]  |  1  3  3  
  [ 1, 1, 1 ]  |  3  2  3  
 Initial states: [ 1 ]
 Final states:   [ 1 ]
gap> P:=PredicatonFromAut(A,[3,2,1],[1,2,3,4]);;
gap> Display(P);
Predicaton: deterministic finite automaton on 16 letters with 3 states, 
the variable position list [ 1, 2, 3, 4 ] and the following transitions:
                  |  1  2  3  
------------------------------
  [ 0, 0, 0, 0 ]  |  1  3  3  
  [ 1, 0, 0, 0 ]  |  3  2  3  
  [ 0, 0, 1, 0 ]  |  3  2  3  
  [ 1, 0, 1, 0 ]  |  2  3  3  
  [ 0, 1, 0, 0 ]  |  3  1  3  
  [ 1, 1, 0, 0 ]  |  1  3  3  
  [ 0, 1, 1, 0 ]  |  1  3  3  
  [ 1, 1, 1, 0 ]  |  3  2  3  
  [ 0, 0, 0, 1 ]  |  1  3  3  
  [ 1, 0, 0, 1 ]  |  3  2  3  
  [ 0, 0, 1, 1 ]  |  3  2  3  
  [ 1, 0, 1, 1 ]  |  2  3  3  
  [ 0, 1, 0, 1 ]  |  3  1  3  
  [ 1, 1, 0, 1 ]  |  1  3  3  
  [ 0, 1, 1, 1 ]  |  1  3  3  
  [ 1, 1, 1, 1 ]  |  3  2  3  
 Initial states: [ 1 ]
 Final states:   [ 1 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="FinitelyManyWordsAccepted" Arg="A"/>
<Description>
The function <C>FinitelyManyWordsAccepted</C> checks if a <C>Predicaton</C> has only finitely many solutions, except the leading zero completion. 
<Example><![CDATA[
gap> P:=Predicaton(Automaton("det", 5, [ [ 0 ], [ 1 ] ], 
> [ [ 4, 2, 2, 3, 5 ], [ 2, 2, 5, 2, 2 ] ], [ 1 ], [ 5 ]), [ 1 ]);;
gap> AcceptedWordsByPredicaton(P);
[ [ 4 ] ]
gap> FinitelyManyWordsAccepted(P);
true
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="PredicatonToRatExp" Arg="P"/>
<Description>
The function <C>PredicatonToRatExp</C> returns the regular expression of the <C>Automaton</C> or <C>Predicaton</C> <A>P</A>.
<Example><![CDATA[
gap> # Continued
gap> P:=Predicaton(Automaton("det", 5, [ [ 0 ], [ 1 ] ],
> [ [ 5, 5, 5, 4, 5 ], [ 2, 3, 4, 5, 5 ] ], [ 1 ], [ 4 ]), [ 1 ]);;
gap> PredicatonToRatExp(P);
[ 1 ][ 1 ][ 1 ][ 0 ]*
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="WordsOfRatExp" Arg="r, depth"/>
<Description>
The function <C>WordsOfRatExp</C> returns all words which can be created from the regular expression <A>r</A> by applying the star operator at most <A>depth</A> times.
<Example><![CDATA[
gap> A:=Automaton("det", 3,
> [ [ 0, 0, 0 ], [ 1, 0, 0 ], [ 0, 1, 0 ], [ 1, 1, 0 ],
> [ 0, 0, 1 ], [ 1, 0, 1 ], [ 0, 1, 1 ], [ 1, 1, 1 ] ],
> [ [ 1, 3, 3 ], [ 3, 2, 3 ], [ 3, 2, 3 ], [ 2, 3, 3 ],
> [ 3, 1, 3 ], [ 1, 3, 3 ], [ 1, 3, 3 ], [ 3, 2, 3 ] ],
> [ 1 ], [ 1 ]);
< deterministic automaton on 8 letters with 3 states >
gap> r:=PredicatonToRatExp(A);
([ 1, 1, 0 ]([ 1, 0, 0 ]U[ 0, 1, 0 ]U[ 1, 1, 1 ])*
 [ 0, 0, 1 ]U[ 0, 0, 0 ]U[ 1, 0, 1 ]U[ 0, 1, 1 ])*
gap> WordsOfRatExp(r, 1);
[ [ [ 1, 1, 0 ], [ 1, 0, 0 ], [ 0, 0, 1 ] ], 
  [ [ 1, 1, 0 ], [ 0, 1, 0 ], [ 0, 0, 1 ] ], 
  [ [ 1, 1, 0 ], [ 1, 1, 1 ], [ 0, 0, 1 ] ], 
  [ [ 1, 1, 0 ], [  ], [ 0, 0, 1 ] ],
  [ [ 0, 0, 0 ] ], [ [ 1, 0, 1 ] ], 
  [ [ 0, 1, 1 ] ],
  [ [  ] ] ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="WordsOfRatExpInterpreted" Arg="r,[ depth]"/>
<Description>
The function <C>WordsOfRatExpInterpreted</C> returns all words which can be created from the regular expression <A>r</A> by applying the star operator at most <A>depth</A> times (default <C>depth=1</C>) as a list of natural numbers.
<Example><![CDATA[
gap> A:=Automaton("det", 3,
> [ [ 0, 0, 0 ], [ 1, 0, 0 ], [ 0, 1, 0 ], [ 1, 1, 0 ],
> [ 0, 0, 1 ], [ 1, 0, 1 ], [ 0, 1, 1 ], [ 1, 1, 1 ] ],
> [ [ 1, 3, 3 ], [ 3, 2, 3 ], [ 3, 2, 3 ], [ 2, 3, 3 ],
> [ 3, 1, 3 ], [ 1, 3, 3 ], [ 1, 3, 3 ], [ 3, 2, 3 ] ],
> [ 1 ], [ 1 ]);
< deterministic automaton on 8 letters with 3 states >
gap> r:=PredicatonToRatExp(A);
([ 1, 1, 0 ]([ 1, 0, 0 ]U[ 0, 1, 0 ]U[ 1, 1, 1 ])*
 [ 0, 0, 1 ]U[ 0, 0, 0 ]U[ 1, 0, 1 ]U[ 0, 1, 1 ])*
gap> WordsOfRatExpInterpreted(r, 1);
[ [ 0, 0, 0 ], [ 0, 1, 1 ], [ 1, 0, 1 ], [ 1, 1, 2 ], [ 1, 3, 4 ], 
  [ 3, 1, 4 ], [ 3, 3, 6 ] ]
]]></Example>
</Description>
</ManSection>

</Section>

<Section Label="Special functions"><Heading>Special functions on Predicata</Heading>


<ManSection>
<Func Name="IsValidInputList" Arg="l, n"/>
<Description>
The function <C>IsValidInputList</C> checks if the lists <A>l</A> and <A>n</A> correct lists for calling a <C>Predicaton</C>, i.e. both lists must contain positive unique integers and <A>l</A> must be a subset of <A>n</A>.
<Example><![CDATA[
gap> IsValidInputList([1,2,3], [1,2,3,4]);
true
gap> IsValidInputList([1,1,2,3], [1,2,3,4]);
Variable position list must contain unique positive integers.
false
gap> IsValidInputList([4,3,5], [4,5]);
Variable position list must be a subset of requested size list. 
Compare: [ 4, 3, 5 ] with [ 4, 5 ]
false
gap> IsValidInputList([4,3,5], [3,4,5,6]);
true
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="BooleanPredicaton" Arg="B, n"/>
<Description>
The function <C>BooleanPredicaton</C> returns the <C>Predicaton</C> which consists of one state. This state is a final state if <A>B</A> is  <C>"true"</C> and a non-final state if <A>B</A> is <C>"false"</C>. The list <A>n</A> gives the resized variable position list.
<Example><![CDATA[
gap> P1:=BooleanPredicaton("true",[]);;
gap> Display(P1);
Predicaton: deterministic finite automaton on 1 letter with 1 state, 
the variable position list [ ] and the following transitions:
       |  1  
-------------
  [ ]  |  1  
 Initial states: [ 1 ]
 Final states:   [ 1 ]
gap> P2:=BooleanPredicaton("false", [ 1, 2 ]);;
gap> Display(P2);
Predicaton: deterministic finite automaton on 4 letters with 1 state, 
the variable position list [ 1, 2 ] and the following transitions:
            |  1  
------------------
  [ 0, 0 ]  |  1  
  [ 1, 0 ]  |  1  
  [ 0, 1 ]  |  1  
  [ 1, 1 ]  |  1  
 Initial states: [ 1 ]
 Final states:   [ ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Var Name="PredicataEqualAut"/>
<Description>
The variable <C>PredicataEqualAut</C> returns the <C>Automaton</C> which recognizes the language of <M>x=y</M>.
<Example><![CDATA[
gap> A:=PredicataEqualAut;
< deterministic automaton on 4 letters with 2 states >
gap> DisplayAut(A);
deterministic finite automaton on 4 letters with 2 states 
and the following transitions:
            |  1  2  
---------------------
  [ 0, 0 ]  |  1  2  
  [ 1, 0 ]  |  2  2  
  [ 0, 1 ]  |  2  2  
  [ 1, 1 ]  |  1  2  
 Initial states: [ 1 ]
 Final states:   [ 1 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="EqualPredicaton" Arg="l, n"/>
<Description>
The function <C>EqualPredicaton</C> returns the <C>Predicaton</C> which recognizes the language of <M>x=y</M>, where <M>x</M> is at position <A>l[1]</A> and <M>y</M> is at position <A>l[2]</A>. The list <A>n</A> gives the resized variable position list.
<Example><![CDATA[
gap> P1:=EqualPredicaton([ 1, 2 ], [ 1, 2 ]);;
gap> Display(P1);
Predicaton: deterministic finite automaton on 4 letters with 2 states, 
the variable position list [ 1, 2 ] and the following transitions:
            |  1  2  
---------------------
  [ 0, 0 ]  |  1  2  
  [ 1, 0 ]  |  2  2  
  [ 0, 1 ]  |  2  2  
  [ 1, 1 ]  |  1  2  
 Initial states: [ 1 ]
 Final states:   [ 1 ]
gap> P2:=EqualPredicaton([ 3, 4 ], [ 1, 2, 3, 4 ]);;
gap> Display(P2);
Predicaton: deterministic finite automaton on 16 letters with 2 states, 
the variable position list [ 1, 2, 3, 4 ] and the following transitions:
                  |  1  2  
---------------------------
  [ 0, 0, 0, 0 ]  |  1  2  
  [ 0, 0, 1, 0 ]  |  2  2  
  [ 0, 0, 0, 1 ]  |  2  2  
  [ 0, 0, 1, 1 ]  |  1  2  
  [ 1, 0, 0, 0 ]  |  1  2  
  [ 1, 0, 1, 0 ]  |  2  2  
  [ 1, 0, 0, 1 ]  |  2  2  
  [ 1, 0, 1, 1 ]  |  1  2  
  [ 0, 1, 0, 0 ]  |  1  2  
  [ 0, 1, 1, 0 ]  |  2  2  
  [ 0, 1, 0, 1 ]  |  2  2  
  [ 0, 1, 1, 1 ]  |  1  2  
  [ 1, 1, 0, 0 ]  |  1  2  
  [ 1, 1, 1, 0 ]  |  2  2  
  [ 1, 1, 0, 1 ]  |  2  2  
  [ 1, 1, 1, 1 ]  |  1  2  
 Initial states: [ 1 ]
 Final states:   [ 1 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Var Name="PredicataAdditionAut"/>
<Description>
The variable <C>PredicataAdditionAut</C> returns the <C>Automaton</C> which recognizes the language <M>x+y=z.</M>
<Example><![CDATA[
gap> A:=PredicataAdditionAut;
< deterministic automaton on 8 letters with 3 states >
gap> DisplayAut(A);
deterministic finite automaton on 8 letters with 3 states 
and the following transitions:
               |  1  2  3  
---------------------------
  [ 0, 0, 0 ]  |  1  3  3  
  [ 1, 0, 0 ]  |  3  2  3  
  [ 0, 1, 0 ]  |  3  2  3  
  [ 1, 1, 0 ]  |  2  3  3  
  [ 0, 0, 1 ]  |  3  1  3  
  [ 1, 0, 1 ]  |  1  3  3  
  [ 0, 1, 1 ]  |  1  3  3  
  [ 1, 1, 1 ]  |  3  2  3  
 Initial states: [ 1 ]
 Final states:   [ 1 ]

]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="AdditionPredicaton" Arg="l, n"/>
<Description>
The function <C>AdditionPredicaton</C> returns the <C>Predicaton</C> which recognizes the language <M>x+y=z</M>, where <M>x</M> is at position <A>l[1]</A>, <M>y</M> is at position <A>l[2]</A> and <M>z</M> is at position <A>l[3]</A>. The list <A>n</A> gives the resized variable position list.
<Example><![CDATA[
gap> P:=AdditionPredicaton([1,2,3],[1,2,3]);;
gap> Display(P);
Predicaton: deterministic finite automaton on 8 letters with 3 states, 
the variable position list [ 1, 2, 3 ] and the following transitions:
               |  1  2  3  
---------------------------
  [ 0, 0, 0 ]  |  1  3  3  
  [ 1, 0, 0 ]  |  3  2  3  
  [ 0, 1, 0 ]  |  3  2  3  
  [ 1, 1, 0 ]  |  2  3  3  
  [ 0, 0, 1 ]  |  3  1  3  
  [ 1, 0, 1 ]  |  1  3  3  
  [ 0, 1, 1 ]  |  1  3  3  
  [ 1, 1, 1 ]  |  3  2  3  
 Initial states: [ 1 ]
 Final states:   [ 1 ]
gap> DisplayAcceptedByPredicaton(P, [ 15, 15, 30 ]);

     | 0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  
 ---------------------------------------------------------------------
   0 | 0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  
   1 | 1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  
   2 | 2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  
   3 | 3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  
   4 | 4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  
   5 | 5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  
   6 | 6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21  
   7 | 7   8   9   10  11  12  13  14  15  16  17  18  19  20  21  22  
   8 | 8   9   10  11  12  13  14  15  16  17  18  19  20  21  22  23  
   9 | 9   10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  
  10 | 10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  
  11 | 11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  
  12 | 12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  
  13 | 13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  
  14 | 14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29  
  15 | 15  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30
  
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="AdditionPredicatonNSummands" Arg="N, l, n"/>
<Description>
The function <C>AdditionPredicatonNSummands</C> calls the function <Ref Func="AdditionPredicatonNSummandsExplicit"/> and returns the <C>Predicaton</C> recognizing the language <M>x_1+\ldots x_N=x_{N+1}</M>. The variables position list <A>l</A> gives the positions of the variables <M>x_i</M> and the list <A>n</A> gives the resized variable position list. The two functions <Ref Func="AdditionPredicatonNSummandsIterative"/> and <Ref Func="AdditionPredicatonNSummandsRecursive"/> create it in a more naive way, i.e. the first creates the <C>Predicaton</C> from the simple automaton recognizing <M>x+y=z</M> step by step and the second creates the <C>Predicaton</C> recursively by splitting the variable position list.
<Example><![CDATA[
gap> P:=AdditionPredicatonNSummands(3, [ 1, 6, 3, 9 ], [ 1, 3, 6, 9 ]);;
gap> Display(P);
Predicaton: deterministic finite automaton on 16 letters with 4 states, 
the variable position list [ 1, 3, 6, 9 ] and the following transitions:
                  |  1  2  3  4  
---------------------------------
  [ 0, 0, 0, 0 ]  |  1  4  2  4  
  [ 1, 0, 0, 0 ]  |  4  2  4  4  
  [ 0, 0, 1, 0 ]  |  4  2  4  4  
  [ 1, 0, 1, 0 ]  |  2  4  3  4  
  [ 0, 1, 0, 0 ]  |  4  2  4  4  
  [ 1, 1, 0, 0 ]  |  2  4  3  4  
  [ 0, 1, 1, 0 ]  |  2  4  3  4  
  [ 1, 1, 1, 0 ]  |  4  3  4  4  
  [ 0, 0, 0, 1 ]  |  4  1  4  4  
  [ 1, 0, 0, 1 ]  |  1  4  2  4  
  [ 0, 0, 1, 1 ]  |  1  4  2  4  
  [ 1, 0, 1, 1 ]  |  4  2  4  4  
  [ 0, 1, 0, 1 ]  |  1  4  2  4  
  [ 1, 1, 0, 1 ]  |  4  2  4  4  
  [ 0, 1, 1, 1 ]  |  4  2  4  4  
  [ 1, 1, 1, 1 ]  |  2  4  3  4  
 Initial states: [ 1 ]
 Final states:   [ 1 ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="TimesNPredicaton" Arg="N, l, n"/>
<Description>
The function <C>TimesNPredicaton</C> returns the <C>Predicaton</C> calls the function <Ref Func="TimesNPredicatonExplicit"/> and returns the <C>Predicaton</C> recognizing the language <M>N\cdot x=y</M>, where <M>x</M> is at position <A>l[1]</A> and <M>y</M> is at position <A>l[2]</A>. Note that <M>N\cdot x</M> is a shortcut for <M>N</M>-times the addition of <M>x</M>. The list <A>n</A> gives the resized variable position list. The function <C>TimesNPredicatonRecursive</C> creates the <C>Predicaton</C> recursively from multiplications with <M>N&lt;10</M>.
<Example><![CDATA[
gap> P:=TimesNPredicaton(10, [ 1, 2 ], [ 1, 2 ]);;
gap> Display(P);
Predicaton: deterministic finite automaton on 4 letters with 11 states, 
the variable position list [ 1, 2 ] and the following transitions:
            |  1  2  3  4  5  6  7  8  9  10 11 
------------------------------------------------
  [ 0, 0 ]  |  1  11 2  11 3  11 4  11 5  11 11 
  [ 1, 0 ]  |  6  11 7  11 8  11 9  11 10 11 11 
  [ 0, 1 ]  |  11 1  11 2  11 3  11 4  11 5  11 
  [ 1, 1 ]  |  11 6  11 7  11 8  11 9  11 10 11 
 Initial states: [ 1 ]
 Final states:   [ 1 ]
gap> AcceptedByPredicaton(P, [ 10, 60 ]);
[ [ 0, 0 ], [ 1, 10 ], [ 2, 20 ], [ 3, 30 ], [ 4, 40 ], [ 5, 50 ], [ 6, 60 ] ]
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="SumOfProductsPredicaton" Arg="l, m, n"/>
<Description>
The function <C>SumOfProductsPredicatonExplicit</C> returns the <C>Predicaton</C> recognizing the language <M>\sum m_i \cdot x_i = 0</M>. The variables position list <A>l</A> gives the positions of the variables <M>x_i</M>, the list <A>m</A> gives the integers (positive or negative) and the list <A>n</A> gives the resized variable position list.
<Example><![CDATA[
gap> P:=SumOfProductsPredicaton([ 1, 2, 3 ], [ 7, 4, -5 ], [ 1, 2, 3 ]);
< Predicaton: deterministic finite automaton on 8 letters with 16 states 
and the variable position list [ 1, 2, 3 ]. >
gap> DisplayAcceptedByPredicaton(P, [ 15, 15, 100 ]);

     | 0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  
 ---------------------------------------------------------------------
   0 | 0   --  --  --  --  4   --  --  --  --  8   --  --  --  --  12  
   1 | --  --  3   --  --  --  --  7   --  --  --  --  11  --  --  --  
   2 | --  --  --  --  6   --  --  --  --  10  --  --  --  --  14  --  
   3 | --  5   --  --  --  --  9   --  --  --  --  13  --  --  --  --  
   4 | --  --  --  8   --  --  --  --  12  --  --  --  --  16  --  --  
   5 | 7   --  --  --  --  11  --  --  --  --  15  --  --  --  --  19  
   6 | --  --  10  --  --  --  --  14  --  --  --  --  18  --  --  --  
   7 | --  --  --  --  13  --  --  --  --  17  --  --  --  --  21  --  
   8 | --  12  --  --  --  --  16  --  --  --  --  20  --  --  --  --  
   9 | --  --  --  15  --  --  --  --  19  --  --  --  --  23  --  --  
  10 | 14  --  --  --  --  18  --  --  --  --  22  --  --  --  --  26  
  11 | --  --  17  --  --  --  --  21  --  --  --  --  25  --  --  --  
  12 | --  --  --  --  20  --  --  --  --  24  --  --  --  --  28  --  
  13 | --  19  --  --  --  --  23  --  --  --  --  27  --  --  --  --  
  14 | --  --  --  22  --  --  --  --  26  --  --  --  --  30  --  --  
  15 | 21  --  --  --  --  25  --  --  --  --  29  --  --  --  --  33  
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="TermEqualTermPredicaton" Arg="l1, m1, i1, l2, m2, i2, n"/>
<Description>
The function <C>TermEqualTermPredicaton</C> returns the <C>Predicaton</C> recognizing the language <M>\sum {m_1}_i \cdot x_i + \sum i_1 = \sum {m_2}_i \cdot y_i + \sum i_2</M>. The variables position lists <A>l1</A> and <A>l2</A> gives the positions of the variables <M>x_i</M> and <M>y_i</M> respectively, the lists <A>m1</A> and <A>m2</A> gives the integers (positive or negative) and the list <A>n</A> gives the resized variable position list. Note: This function allows double occurrences of the same variable in both variable position lists <A>l1</A> and <A>l2</A>. The lists <A>i1</A> and <A>i1</A> gives the integer additions on the left and right side, whereas <A>l1</A> and <A>m1</A> or <A>l2</A> and <A>m2</A> must contain at it's position <C>"int"</C>. This function calls <Ref Func="SumOfProductsPredicaton"/>.
<Example><![CDATA[
gap> # 5*x1 + 2*x1 + 4 = 6*x2 + 1*x3
gap> P:=TermEqualTermPredicaton( [ 1, 1, "int" ], [ 5, 2, "int" ], [ 4 ], 
> [ 2, 3 ], [ 6, 1 ], [ ], [ 1, 2, 3 ]);
< Predicaton: deterministic finite automaton on 8 letters with 14 states 
and the variable position list [ 1, 2, 3 ]. >
gap> AcceptedByPredicaton(P);
[ [ 0, 0, 4 ], [ 1, 1, 5 ], [ 2, 2, 6 ], [ 2, 3, 0 ], [ 3, 3, 7 ], [ 3, 4, 1 ],
  [ 4, 4, 8 ], [ 4, 5, 2 ], [ 5, 5, 9 ], [ 5, 6, 3 ], [ 6, 6, 10 ], [ 6, 7, 4 ],
  [ 7, 8, 5 ], [ 8, 9, 6 ], [ 8, 10, 0 ], [ 9, 10, 7 ] ]
gap> DisplayAcceptedByPredicaton(P, [10, 15, 100]);

     | 0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  
 ---------------------------------------------------------------------
   0 | 4   --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  
   1 | 11  5   --  --  --  --  --  --  --  --  --  --  --  --  --  --  
   2 | 18  12  6   0   --  --  --  --  --  --  --  --  --  --  --  --  
   3 | 25  19  13  7   1   --  --  --  --  --  --  --  --  --  --  --  
   4 | 32  26  20  14  8   2   --  --  --  --  --  --  --  --  --  --  
   5 | 39  33  27  21  15  9   3   --  --  --  --  --  --  --  --  --  
   6 | 46  40  34  28  22  16  10  4   --  --  --  --  --  --  --  --  
   7 | 53  47  41  35  29  23  17  11  5   --  --  --  --  --  --  --  
   8 | 60  54  48  42  36  30  24  18  12  6   0   --  --  --  --  --  
   9 | 67  61  55  49  43  37  31  25  19  13  7   1   --  --  --  --  
  10 | 74  68  62  56  50  44  38  32  26  20  14  8   2   --  --  --  

]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="GreaterEqualNPredicaton" Arg="N, l, n"/>
<Description>
The function <C>GreaterEqualNPredicaton</C> returns the <C>Predicaton</C> recognizing the language <M>x&gt;=N</M>.
<Example><![CDATA[
gap> P:=GreaterEqualNPredicaton(15, [ 1 ], [ 1 ]);;
gap> P:=SortedStatesAut(P);;
gap> Display(P);
Predicaton: deterministic finite automaton on 2 letters with 8 states, 
the variable position list [ 1 ] and the following transitions:
         |  1  2  3  4  5  6  7  8  
------------------------------------
  [ 0 ]  |  7  6  3  3  4  4  6  8  
  [ 1 ]  |  2  5  8  3  3  4  6  8  
 Initial states: [ 1 ]
 Final states:   [ 8 ]
gap> DisplayAcceptedByPredicaton(P, 29, true);
 If the following words are accepted by the given automaton, then: Y, 
 otherwise if not accepted: n.
   0: n   1: n   2: n   3: n   4: n   5: n   6: n   7: n   8: n   9: n
  10: n  11: n  12: n  13: n  14: n  15: Y  16: Y  17: Y  18: Y  19: Y
  20: Y  21: Y  22: Y  23: Y  24: Y  25: Y  26: Y  27: Y  28: Y  29: Y
 
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="GreaterNPredicaton" Arg="N, l, n"/>
<Description>
The function <C>GreaterNPredicaton</C> returns the <C>Predicaton</C> recognizing the language <M>x&gt;N</M>.
<Example><![CDATA[
gap> P:=GreaterNPredicaton(15, [ 1 ], [ 1 ]);;
gap> P:=SortedStatesAut(P);;
gap> Display(P);
Predicaton: deterministic finite automaton on 2 letters with 6 states, 
the variable position list [ 1 ] and the following transitions:
         |  1  2  3  4  5  6  
------------------------------
  [ 0 ]  |  5  2  2  3  4  6  
  [ 1 ]  |  5  6  2  3  4  6  
 Initial states: [ 1 ]
 Final states:   [ 6 ]
gap> DisplayAcceptedByPredicaton(P, 29, true);
 If the following words are accepted by the given automaton, then: Y, 
 otherwise if not accepted: n.
   0: n   1: n   2: n   3: n   4: n   5: n   6: n   7: n   8: n   9: n
  10: n  11: n  12: n  13: n  14: n  15: n  16: Y  17: Y  18: Y  19: Y
  20: Y  21: Y  22: Y  23: Y  24: Y  25: Y  26: Y  27: Y  28: Y  29: Y
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="SmallerEqualNPredicaton" Arg="N, l, n"/>
<Description>
The function <C>SmallerEqualNPredicaton</C> returns the <C>Predicaton</C> recognizing the language <M>x&lt;=N</M>.
<Example><![CDATA[
gap> P:=SmallerEqualNPredicaton(15, [ 1 ], [ 1 ]);;
gap> P:=SortedStatesAut(P);;
gap> Display(P);
Predicaton: deterministic finite automaton on 2 letters with 6 states, 
the variable position list [ 1 ] and the following transitions:
         |  1  2  3  4  5  6  
------------------------------
  [ 0 ]  |  6  2  3  3  4  5  
  [ 1 ]  |  6  2  2  3  4  5  
 Initial states: [ 1 ]
 Final states:   [ 1, 3, 4, 5, 6 ]
gap> DisplayAcceptedByPredicaton(P, 29, true);
 If the following words are accepted by the given automaton, then: Y, 
 otherwise if not accepted: n.
   0: Y   1: Y   2: Y   3: Y   4: Y   5: Y   6: Y   7: Y   8: Y   9: Y
  10: Y  11: Y  12: Y  13: Y  14: Y  15: Y  16: n  17: n  18: n  19: n
  20: n  21: n  22: n  23: n  24: n  25: n  26: n  27: n  28: n  29: n
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="SmallerNPredicaton" Arg="N, l, n"/>
<Description>
The function <C>SmallerNPredicaton</C> returns the <C>Predicaton</C> recognizing the language <M>x&lt;N</M>.
<Example><![CDATA[
gap> P:=SmallerNPredicaton(15, [ 1 ], [ 1 ]);;
gap> P:=SortedStatesAut(P);;
gap> Display(P);
Predicaton: deterministic finite automaton on 2 letters with 8 states, 
the variable position list [ 1 ] and the following transitions:
         |  1  2  3  4  5  6  7  8  
------------------------------------
  [ 0 ]  |  8  2  7  4  4  5  5  7  
  [ 1 ]  |  3  2  6  2  4  4  5  7  
 Initial states: [ 1 ]
 Final states:   [ 1, 3, 4, 5, 6, 7, 8 ]
gap> DisplayAcceptedByPredicaton(P, 29, true);
 If the following words are accepted by the given automaton,  then: Y, 
 otherwise if not accepted: n.
   0: Y   1: Y   2: Y   3: Y   4: Y   5: Y   6: Y   7: Y   8: Y   9: Y
  10: Y  11: Y  12: Y  13: Y  14: Y  15: n  16: n  17: n  18: n  19: n
  20: n  21: n  22: n  23: n  24: n  25: n  26: n  27: n  28: n  29: n

]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="GreaterEqualPredicaton" Arg="l, n"/>
<Description>
The function <C>GreaterEqualPredicaton</C> returns the <C>Predicaton</C> recognizing the language <M>x&gt;=y</M> with the variables position list <A>l</A> giving the positions of the variables <M>x</M> and <M>y</M>. The list <A>n</A> gives the resized variable position list.
<Example><![CDATA[
gap> P:=GreaterEqualPredicaton([1,2],[1,2]);;
gap> Display(P);
Predicaton: deterministic finite automaton on 4 letters with 2 states, 
the variable position list [ 1, 2 ] and the following transitions:
            |  1  2  
---------------------
  [ 0, 0 ]  |  1  2  
  [ 1, 0 ]  |  2  2  
  [ 0, 1 ]  |  1  1  
  [ 1, 1 ]  |  1  2  
 Initial states: [ 2 ]
 Final states:   [ 2 ]
gap> DisplayAcceptedByPredicaton(P, 10);
 If the following words are accepted by the given automaton, then: YES, 
 otherwise if not accepted: no.
     | 0   1   2   3   4   5   6   7   8   9   10  
 -------------------------------------------------
   0 | YES no  no  no  no  no  no  no  no  no  no  
   1 | YES YES no  no  no  no  no  no  no  no  no  
   2 | YES YES YES no  no  no  no  no  no  no  no  
   3 | YES YES YES YES no  no  no  no  no  no  no  
   4 | YES YES YES YES YES no  no  no  no  no  no  
   5 | YES YES YES YES YES YES no  no  no  no  no  
   6 | YES YES YES YES YES YES YES no  no  no  no  
   7 | YES YES YES YES YES YES YES YES no  no  no  
   8 | YES YES YES YES YES YES YES YES YES no  no  
   9 | YES YES YES YES YES YES YES YES YES YES no  
  10 | YES YES YES YES YES YES YES YES YES YES YES 
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="GreaterPredicaton" Arg="l, n"/>
<Description>
The function <C>GreaterPredicaton</C> returns the <C>Predicaton</C> recognizing the language <M>x&gt;y</M> with the variables position list <A>l</A> giving the positions of the variables <M>x</M> and <M>y</M>. The list <A>n</A> gives the resized variable position list.
<Example><![CDATA[
gap> P:=GreaterPredicaton([1,2],[1,2]);;
gap> Display(P);
Predicaton: deterministic finite automaton on 4 letters with 2 states, 
the variable position list [ 1, 2 ] and the following transitions:
            |  1  2  
---------------------
  [ 0, 0 ]  |  1  2  
  [ 1, 0 ]  |  1  1  
  [ 0, 1 ]  |  2  2  
  [ 1, 1 ]  |  1  2  
 Initial states: [ 2 ]
 Final states:   [ 1 ]
gap> DisplayAcceptedByPredicaton(P, 10);
 If the following words are accepted by the given automaton, then: YES, 
 otherwise if not accepted: no.
     | 0   1   2   3   4   5   6   7   8   9   10  
 -------------------------------------------------
   0 | no  no  no  no  no  no  no  no  no  no  no  
   1 | YES no  no  no  no  no  no  no  no  no  no  
   2 | YES YES no  no  no  no  no  no  no  no  no  
   3 | YES YES YES no  no  no  no  no  no  no  no  
   4 | YES YES YES YES no  no  no  no  no  no  no  
   5 | YES YES YES YES YES no  no  no  no  no  no  
   6 | YES YES YES YES YES YES no  no  no  no  no  
   7 | YES YES YES YES YES YES YES no  no  no  no  
   8 | YES YES YES YES YES YES YES YES no  no  no  
   9 | YES YES YES YES YES YES YES YES YES no  no  
  10 | YES YES YES YES YES YES YES YES YES YES no  
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="SmallerEqualPredicaton" Arg="l, n"/>
<Description>
The function <C>SmallerEqualPredicaton</C> returns the <C>Predicaton</C> recognizing the language <M>x&lt;=y</M> with the variables position list <A>l</A> giving the positions of the variables <M>x</M> and <M>y</M>. The list <A>n</A> gives the resized variable position list.
<Example><![CDATA[
gap> P:=SmallerEqualPredicaton([ 1, 2 ], [ 1, 2 ]);;
gap> Display(P);
Predicaton: deterministic finite automaton on 4 letters with 2 states, 
the variable position list [ 1, 2 ] and the following transitions:
            |  1  2  
---------------------
  [ 0, 0 ]  |  1  2  
  [ 1, 0 ]  |  1  1  
  [ 0, 1 ]  |  2  2  
  [ 1, 1 ]  |  1  2  
 Initial states: [ 2 ]
 Final states:   [ 2 ]
gap> DisplayAcceptedByPredicaton(P, 10);
 If the following words are accepted by the given automaton, then: YES, 
 otherwise if not accepted: no.
     | 0   1   2   3   4   5   6   7   8   9   10  
 -------------------------------------------------
   0 | YES YES YES YES YES YES YES YES YES YES YES 
   1 | no  YES YES YES YES YES YES YES YES YES YES 
   2 | no  no  YES YES YES YES YES YES YES YES YES 
   3 | no  no  no  YES YES YES YES YES YES YES YES 
   4 | no  no  no  no  YES YES YES YES YES YES YES 
   5 | no  no  no  no  no  YES YES YES YES YES YES 
   6 | no  no  no  no  no  no  YES YES YES YES YES 
   7 | no  no  no  no  no  no  no  YES YES YES YES 
   8 | no  no  no  no  no  no  no  no  YES YES YES 
   9 | no  no  no  no  no  no  no  no  no  YES YES 
  10 | no  no  no  no  no  no  no  no  no  no  YES 
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="SmallerPredicaton" Arg="l, n"/>
<Description>
The function <C>SmallerPredicaton</C> returns the <C>Predicaton</C> recognizing the language <M>x&lt;y</M> with the variables position list <A>l</A> giving the positions of the variables <M>x</M> and <M>y</M>. The list <A>n</A> gives the resized variable position list.
<Example><![CDATA[
gap> P:=SmallerPredicaton([ 1, 2 ], [ 1, 2 ]);;
gap> Display(P);
Predicaton: deterministic finite automaton on 4 letters with 2 states, 
the variable position list [ 1, 2 ] and the following transitions:
            |  1  2  
---------------------
  [ 0, 0 ]  |  1  2  
  [ 1, 0 ]  |  2  2  
  [ 0, 1 ]  |  1  1  
  [ 1, 1 ]  |  1  2  
 Initial states: [ 2 ]
 Final states:   [ 1 ]
gap> DisplayAcceptedByPredicaton(P, 10);
 If the following words are accepted by the given automaton, then: YES, 
 otherwise if not accepted: no.
     | 0   1   2   3   4   5   6   7   8   9   10  
 -------------------------------------------------
   0 | no  YES YES YES YES YES YES YES YES YES YES 
   1 | no  no  YES YES YES YES YES YES YES YES YES 
   2 | no  no  no  YES YES YES YES YES YES YES YES 
   3 | no  no  no  no  YES YES YES YES YES YES YES 
   4 | no  no  no  no  no  YES YES YES YES YES YES 
   5 | no  no  no  no  no  no  YES YES YES YES YES 
   6 | no  no  no  no  no  no  no  YES YES YES YES 
   7 | no  no  no  no  no  no  no  no  YES YES YES 
   8 | no  no  no  no  no  no  no  no  no  YES YES 
   9 | no  no  no  no  no  no  no  no  no  no  YES 
  10 | no  no  no  no  no  no  no  no  no  no  no  
]]></Example>
</Description>
</ManSection>

</Section>

<Section><Heading>Detailed look at the special functions on Predicata</Heading>
This section explains how the sums and products are computed and describes different methods. The explicit method, which computes the transition matrix with a transition formula, is more efficient than the other given methods. The recursive and iterative methods explain a more naive way how to compute the requested automaton, but are lacking in speed. Therefore they are not used in any further computation.

<ManSection>
<Func Name="AdditionPredicaton3Summands" Arg="l, n"/>
<Func Name="AdditionPredicaton4Summands" Arg="l, n"/>
<Func Name="AdditionPredicaton5Summands" Arg="l, n"/>
<Description>
The functions <C>AdditionPredicatonNSummands</C> returns the <C>Predicaton</C> recognizing the language <M>x_1+\ldots x_N=x_{N+1}</M> for <M>N=3,4,5</M>.
<Example><![CDATA[
gap> P:=AdditionPredicaton3Summands([ 1, 2, 3, 4 ],[ 1, 2, 3, 4 ]);
< Predicaton: deterministic finite automaton on 16 letters with 4 states 
and the variable position list [ 1, 2, 3, 4 ]. >
gap> P:=AdditionPredicaton4Summands([ 1, 2, 3, 4, 5 ], [ 1, 2, 3, 4, 5 ]);
< Predicaton: deterministic finite automaton on 32 letters with 5 states 
and the variable position list [ 1, 2, 3, 4, 5 ]. >
gap> P:=AdditionPredicaton5Summands([ 1, 2, 3, 4, 5, 6 ], [ 1, 2, 3, 4, 5, 6 ]);
< Predicaton: deterministic finite automaton on 64 letters with 6 states 
and the variable position list [ 1, 2, 3, 4, 5, 6 ]. >

]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="AdditionPredicatonNSummandsExplicit" Arg="N, l, n"/>
<Description>
The function <C>AdditionPredicatonNSummandsExplicit</C> returns the <C>Predicaton</C> recognizing the language <M>x_1+\ldots x_N=x_{N+1}</M>. 
The <C>TransitionTable</C> is assigned explicitly with the following transition property: The <M>i</M>-th state denotes carry <M>i</M> and there is a transition from state <M>i</M> to state <M>j</M> for the letter <M>a</M> if <Math>\sum_{i=1}^{N}a_i = a_{N+1} + i + 2 (j-i)</Math> holds. The variables position list <A>l</A> gives the positions of the variables <M>x_i</M> and the list <A>n</A> gives the resized variable position list. 
<Example><![CDATA[
gap> P:=AdditionPredicatonNSummandsExplicit(3, [6, 11, 2, 9], [2, 3, 6, 7, 9, 11]);
< Predicaton: deterministic finite automaton on 64 letters with 4 states 
and the variable position list [ 2, 3, 6, 7, 9, 11 ]. >
gap> P:=AdditionPredicatonNSummandsExplicit(11, [ 1..12 ], [ 1..12 ]);
< Predicaton: deterministic finite automaton on 4096 letters with 12 states 
and the variable position list 
[ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 ]. >
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="AdditionPredicatonNSummandsIterative" Arg="N, l, n"/>
<Description>
The function <C>AdditionPredicatonNSummandsIterative</C> returns the <C>Predicaton</C> recognizing the language <M>x_1+\ldots x_N=x_{N+1}</M>. 
The <C>Predicaton</C> is created by intersection <M>(N-1)</M>-times the simple automaton recognizing <M>x+y=z</M>. Due to intersecting and minimizing that often, this function shouldn't be used for large <M>N</M> (for example <M>N&gt;10</M>).
<Example><![CDATA[
gap> P:=AdditionPredicatonNSummandsIterative(7, [ 1..8 ], [ 1..8 ]);
< Predicaton: deterministic finite automaton on 256 letters with 8 states 
and the variable position list [ 1, 2, 3, 4, 5, 6, 7, 8 ]. >
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="AdditionPredicatonNSummandsRecursive" Arg="N, l, n"/>
<Description>
The function <C>AdditionPredicatonNSummandsRecursive</C> returns the <C>Predicaton</C> recognizing the language <M>x_1+\ldots x_N=x_{N+1}</M>. 
The <C>Predicaton</C> is created recursively splitting the variable position list until a length of 3 is reached, where the base cases are the simple automaton recognizing <M>x+y=z</M>. It is slightly faster than <Ref Func="AdditionPredicatonNSummandsIterative"/> but nevertheless it shouldn't be used for large <M>N</M> (for example <M>N&gt;10</M>).
<Example><![CDATA[
gap> P:=AdditionPredicatonNSummandsRecursive(7, [ 1..8 ], [ 1..8 ]);
< Predicaton: deterministic finite automaton on 256 letters with 8 states 
and the variable position list [ 1, 2, 3, 4, 5, 6, 7, 8 ]. >
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="TimesNPredicatonExplicit" Arg="N, l, n"/>
<Description>
The function <C>TimesNPredicatonExplicit</C> returns the <C>Predicaton</C> recognizing the language <M>N\cdot x=y</M>. 
The <C>TransitionTable</C> is assigned explicitly with the following transition property: The <M>i</M>-th state denotes carry <M>i</M> and there is a transition from state <M>i</M> to state <M>j</M> for the letter <M>a</M> if <Math>N \cdot a_1 = a_2 + i + 2 (j - i).</Math> The variables position list <A>l</A> gives the positions of the variables <M>x_i</M> and the list <A>n</A> gives the resized variable position list. 
<Example><![CDATA[
gap> P:=TimesNPredicatonExplicit(1000, [ 1, 2 ], [ 1, 2 ]);
< Predicaton: deterministic finite automaton on 4 letters with 1001 states 
and the variable position list [ 1, 2 ]. >
gap> IsAcceptedByPredicaton(P, [ 1, 1000 ]);
true
gap> IsAcceptedByPredicaton(P, [ 2, 2000 ]);
true
gap> IsAcceptedByPredicaton(P, [ 3, 3000 ]);
true
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="TimesNPredicatonRecursive" Arg="N, l, n"/>
<Description>
The function <C>TimesNPredicatonRecursive</C> returns the <C>Predicaton</C> recognizing the language <M>N \cdot x=y</M>. It splits the the multiplication into a multiplications of <M>N_1</M> and <M>N_2</M>, where <M>N = N_1 \cdot N_2</M>.
<Example><![CDATA[
gap> P:=TimesNPredicatonRecursive(100, [1,2],[1,2]);
< Predicaton: deterministic finite automaton on 4 letters with 101 states 
and the variable position list [ 1, 2 ]. >
gap> P:=TimesNPredicatonRecursive(1000, [1,2],[1,2]);
< Predicaton: deterministic finite automaton on 4 letters with 1001 states 
and the variable position list [ 1, 2 ]. >
]]></Example>
</Description>
</ManSection>

<ManSection>
<Func Name="Times2Predicaton" Arg="l, n"/>
<Func Name="Times3Predicaton" Arg="l, n"/>
<Func Name="Times4Predicaton" Arg="l, n"/>
<Func Name="Times5Predicaton" Arg="l, n"/>
<Func Name="Times6Predicaton" Arg="l, n"/>
<Func Name="Times7Predicaton" Arg="l, n"/>
<Func Name="Times8Predicaton" Arg="l, n"/>
<Func Name="Times9Predicaton" Arg="l, n"/>
<Description>
The functions <C>Times2Predicaton</C>, <C>Times3Predicaton</C>,... returns the <C>Predicaton</C> recognizing the language <M>N \cdot x=y</M> for <M>N=2,\ldots,9</M>.
<Example><![CDATA[
gap> P:=Times2Predicaton([ 1, 2 ], [ 1, 2 ]);;
gap> Display(P);
Predicaton: deterministic finite automaton on 4 letters with 3 states, 
the variable position list [ 1, 2 ] and the following transitions:
            |  1  2  3  
------------------------
  [ 0, 0 ]  |  1  3  3  
  [ 1, 0 ]  |  2  3  3  
  [ 0, 1 ]  |  3  1  3  
  [ 1, 1 ]  |  3  2  3  
 Initial states: [ 1 ]
 Final states:   [ 1 ]
gap> P:=Times3Predicaton([ 1, 2 ], [ 1, 2 ]);;
gap> Display(P);
Predicaton: deterministic finite automaton on 4 letters with 4 states, 
the variable position list [ 1, 2 ] and the following transitions:
            |  1  2  3  4  
---------------------------
  [ 0, 0 ]  |  1  4  2  4  
  [ 1, 0 ]  |  4  3  4  4  
  [ 0, 1 ]  |  4  1  4  4  
  [ 1, 1 ]  |  2  4  3  4  
 Initial states: [ 1 ]
 Final states:   [ 1 ]
]]></Example>
</Description>
</ManSection>
</Section>

</Chapter>
